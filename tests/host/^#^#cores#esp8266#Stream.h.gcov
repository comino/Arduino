        -:    0:Source:../../cores/esp8266/Stream.h
        -:    0:Programs:14
        -:    1:/*
        -:    2: Stream.h - base class for character-based streams.
        -:    3: Copyright (c) 2010 David A. Mellis.  All right reserved.
        -:    4:
        -:    5: This library is free software; you can redistribute it and/or
        -:    6: modify it under the terms of the GNU Lesser General Public
        -:    7: License as published by the Free Software Foundation; either
        -:    8: version 2.1 of the License, or (at your option) any later version.
        -:    9:
        -:   10: This library is distributed in the hope that it will be useful,
        -:   11: but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   13: Lesser General Public License for more details.
        -:   14:
        -:   15: You should have received a copy of the GNU Lesser General Public
        -:   16: License along with this library; if not, write to the Free Software
        -:   17: Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
        -:   18:
        -:   19: parsing functions based on TextFinder library by Michael Margolis
        -:   20: */
        -:   21:
        -:   22:#ifndef Stream_h
        -:   23:#define Stream_h
        -:   24:
        -:   25:#include <inttypes.h>
        -:   26:#include "Print.h"
        -:   27:
        -:   28:// compatability macros for testing
        -:   29:/*
        -:   30: #define   getInt()            parseInt()
        -:   31: #define   getInt(skipChar)    parseInt(skipchar)
        -:   32: #define   getFloat()          parseFloat()
        -:   33: #define   getFloat(skipChar)  parseFloat(skipChar)
        -:   34: #define   getString( pre_string, post_string, buffer, length)
        -:   35: readBytesBetween( pre_string, terminator, buffer, length)
        -:   36: */
        -:   37:
        -:   38:class Stream: public Print {
        -:   39:    protected:
        -:   40:        unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
        -:   41:        unsigned long _startMillis;  // used for timeout measurement
        -:   42:        int timedRead();    // private method to read stream with timeout
        -:   43:        int timedPeek();    // private method to peek stream with timeout
        -:   44:        int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
        -:   45:
        -:   46:    public:
        -:   47:        virtual int available() = 0;
        -:   48:        virtual int read() = 0;
        -:   49:        virtual int peek() = 0;
        -:   50:        virtual void flush() = 0;
        -:   51:
function _ZN6StreamC2Ev called 0 returned 0% blocks executed 0%
    #####:   52:        Stream() {
call    0 never executed
    #####:   53:            _timeout = 1000;
    #####:   54:        }
        -:   55:
        -:   56:// parsing methods
        -:   57:
        -:   58:        void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
        -:   59:
        -:   60:        bool find(const char *target);   // reads data from the stream until the target string is found
        -:   61:        bool find(uint8_t *target) {
        -:   62:            return find((char *) target);
        -:   63:        }
        -:   64:        // returns true if target string is found, false if timed out (see setTimeout)
        -:   65:
        -:   66:        bool find(const char *target, size_t length);   // reads data from the stream until the target string of given length is found
        -:   67:        bool find(const uint8_t *target, size_t length) {
        -:   68:            return find((char *) target, length);
        -:   69:        }
        -:   70:        // returns true if target string is found, false if timed out
        -:   71:
        -:   72:        bool find(char target) { return find (&target, 1); }
        -:   73:
        -:   74:        bool findUntil(const char *target, const char *terminator);   // as find but search ends if the terminator string is found
        -:   75:        bool findUntil(const uint8_t *target, const char *terminator) {
        -:   76:            return findUntil((char *) target, terminator);
        -:   77:        }
        -:   78:
        -:   79:        bool findUntil(const char *target, size_t targetLen, const char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
        -:   80:        bool findUntil(const uint8_t *target, size_t targetLen, const char *terminate, size_t termLen) {
        -:   81:            return findUntil((char *) target, targetLen, terminate, termLen);
        -:   82:        }
        -:   83:
        -:   84:        long parseInt(); // returns the first valid (long) integer value from the current position.
        -:   85:        // initial characters that are not digits (or the minus sign) are skipped
        -:   86:        // integer is terminated by the first character that is not a digit.
        -:   87:
        -:   88:        float parseFloat();               // float version of parseInt
        -:   89:
        -:   90:        virtual size_t readBytes(char *buffer, size_t length); // read chars from stream into buffer
function _ZN6Stream9readBytesEPhm called 0 returned 0% blocks executed 0%
function _ZN6Stream9readBytesEPhm called 0 returned 0% blocks executed 0%
function _ZN6Stream9readBytesEPhm called 3 returned 100% blocks executed 100%
        3:   91:        virtual size_t readBytes(uint8_t *buffer, size_t length) {
        3:   92:            return readBytes((char *) buffer, length);
call    0 never executed
call    1 never executed
call    2 returned 100%
        -:   93:        }
        -:   94:        // terminates if length characters have been read or timeout (see setTimeout)
        -:   95:        // returns the number of characters placed in the buffer (0 means no valid data found)
        -:   96:
        -:   97:        size_t readBytesUntil(char terminator, char *buffer, size_t length); // as readBytes with terminator character
        -:   98:        size_t readBytesUntil(char terminator, uint8_t *buffer, size_t length) {
        -:   99:            return readBytesUntil(terminator, (char *) buffer, length);
        -:  100:        }
        -:  101:        // terminates if length characters have been read, timeout, or if the terminator character  detected
        -:  102:        // returns the number of characters placed in the buffer (0 means no valid data found)
        -:  103:
        -:  104:        // Arduino String functions to be added here
        -:  105:        String readString();
        -:  106:        String readStringUntil(char terminator);
        -:  107:
        -:  108:    protected:
        -:  109:        long parseInt(char skipChar); // as above but the given skipChar is ignored
        -:  110:        // as above but the given skipChar is ignored
        -:  111:        // this allows format characters (typically commas) in values to be ignored
        -:  112:
        -:  113:        float parseFloat(char skipChar);  // as above but the given skipChar is ignored
        -:  114:};
        -:  115:
        -:  116:#endif
