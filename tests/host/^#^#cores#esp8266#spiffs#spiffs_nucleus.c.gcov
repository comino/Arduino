        -:    0:Source:../../cores/esp8266/spiffs/spiffs_nucleus.c
        -:    0:Programs:14
        -:    1:#include "spiffs.h"
        -:    2:#include "spiffs_nucleus.h"
        -:    3:
function spiffs_page_data_check called 17 returned 100% blocks executed 60%
       17:    4:static s32_t spiffs_page_data_check(spiffs *fs, spiffs_fd *fd, spiffs_page_ix pix, spiffs_span_ix spix) {
       17:    5:  s32_t res = SPIFFS_OK;
       17:    6:  if (pix == (spiffs_page_ix)-1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:    7:    // referring to page 0xffff...., bad object index
    #####:    8:    return SPIFFS_ERR_INDEX_REF_FREE;
        -:    9:  }
       17:   10:  if (pix % SPIFFS_PAGES_PER_BLOCK(fs) < SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   11:    // referring to an object lookup page, bad object index
    #####:   12:    return SPIFFS_ERR_INDEX_REF_LU;
        -:   13:  }
       17:   14:  if (pix > SPIFFS_MAX_PAGES(fs)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   15:    // referring to a bad page
    #####:   16:    return SPIFFS_ERR_INDEX_REF_INVALID;
        -:   17:  }
        -:   18:#if SPIFFS_PAGE_CHECK
        -:   19:  spiffs_page_header ph;
       17:   20:  res = _spiffs_rd(
call    0 returned 100%
        -:   21:      fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_READ,
        -:   22:      fd->file_nbr,
        -:   23:      SPIFFS_PAGE_TO_PADDR(fs, pix),
        -:   24:      sizeof(spiffs_page_header),
        -:   25:      (u8_t *)&ph);
       17:   26:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       17:   27:  SPIFFS_VALIDATE_DATA(ph, fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG, spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
        -:   28:#endif
       17:   29:  return res;
        -:   30:}
        -:   31:
        -:   32:#if !SPIFFS_READ_ONLY
function spiffs_page_index_check called 13 returned 100% blocks executed 59%
       13:   33:static s32_t spiffs_page_index_check(spiffs *fs, spiffs_fd *fd, spiffs_page_ix pix, spiffs_span_ix spix) {
       13:   34:  s32_t res = SPIFFS_OK;
       13:   35:  if (pix == (spiffs_page_ix)-1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   36:    // referring to page 0xffff...., bad object index
    #####:   37:    return SPIFFS_ERR_INDEX_FREE;
        -:   38:  }
       13:   39:  if (pix % SPIFFS_PAGES_PER_BLOCK(fs) < SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   40:    // referring to an object lookup page, bad object index
    #####:   41:    return SPIFFS_ERR_INDEX_LU;
        -:   42:  }
       13:   43:  if (pix > SPIFFS_MAX_PAGES(fs)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   44:    // referring to a bad page
    #####:   45:    return SPIFFS_ERR_INDEX_INVALID;
        -:   46:  }
        -:   47:#if SPIFFS_PAGE_CHECK
        -:   48:  spiffs_page_header ph;
       13:   49:  res = _spiffs_rd(
call    0 returned 100%
        -:   50:      fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
        -:   51:      fd->file_nbr,
        -:   52:      SPIFFS_PAGE_TO_PADDR(fs, pix),
        -:   53:      sizeof(spiffs_page_header),
        -:   54:      (u8_t *)&ph);
       13:   55:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       13:   56:  SPIFFS_VALIDATE_OBJIX(ph, fd->obj_id, spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
        -:   57:#endif
       13:   58:  return res;
        -:   59:}
        -:   60:#endif // !SPIFFS_READ_ONLY
        -:   61:
        -:   62:#if !SPIFFS_CACHE
        -:   63:
        -:   64:s32_t spiffs_phys_rd(
        -:   65:    spiffs *fs,
        -:   66:    u32_t addr,
        -:   67:    u32_t len,
        -:   68:    u8_t *dst) {
        -:   69:  return SPIFFS_HAL_READ(fs, addr, len, dst);
        -:   70:}
        -:   71:
        -:   72:s32_t spiffs_phys_wr(
        -:   73:    spiffs *fs,
        -:   74:    u32_t addr,
        -:   75:    u32_t len,
        -:   76:    u8_t *src) {
        -:   77:  return SPIFFS_HAL_WRITE(fs, addr, len, src);
        -:   78:}
        -:   79:
        -:   80:#endif
        -:   81:
        -:   82:#if !SPIFFS_READ_ONLY
function spiffs_phys_cpy called 0 returned 0% blocks executed 0%
    #####:   83:s32_t spiffs_phys_cpy(
        -:   84:    spiffs *fs,
        -:   85:    spiffs_file fh,
        -:   86:    u32_t dst,
        -:   87:    u32_t src,
        -:   88:    u32_t len) {
        -:   89:  (void)fh;
        -:   90:  s32_t res;
        -:   91:  u8_t b[SPIFFS_COPY_BUFFER_STACK];
    #####:   92:  while (len > 0) {
branch  0 never executed
branch  1 never executed
    #####:   93:    u32_t chunk_size = MIN(SPIFFS_COPY_BUFFER_STACK, len);
    #####:   94:    res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_MOVS, fh, src, chunk_size, b);
call    0 never executed
    #####:   95:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:   96:    res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_MOVD,  fh, dst, chunk_size, b);
call    0 never executed
    #####:   97:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:   98:    len -= chunk_size;
    #####:   99:    src += chunk_size;
    #####:  100:    dst += chunk_size;
        -:  101:  }
    #####:  102:  return SPIFFS_OK;
        -:  103:}
        -:  104:#endif // !SPIFFS_READ_ONLY
        -:  105:
        -:  106:// Find object lookup entry containing given id with visitor.
        -:  107:// Iterate over object lookup pages in each block until a given object id entry is found.
        -:  108:// When found, the visitor function is called with block index, entry index and user data.
        -:  109:// If visitor returns SPIFFS_VIS_CONTINUE, the search goes on. Otherwise, the search will be
        -:  110:// ended and visitor's return code is returned to caller.
        -:  111:// If no visitor is given (0) the search returns on first entry with matching object id.
        -:  112:// If no match is found in all look up, SPIFFS_VIS_END is returned.
        -:  113:// @param fs                    the file system
        -:  114:// @param starting_block        the starting block to start search in
        -:  115:// @param starting_lu_entry     the look up index entry to start search in
        -:  116:// @param flags                 ored combination of SPIFFS_VIS_CHECK_ID, SPIFFS_VIS_CHECK_PH,
        -:  117://                              SPIFFS_VIS_NO_WRAP
        -:  118:// @param obj_id                argument object id
        -:  119:// @param v                     visitor callback function
        -:  120:// @param user_const_p          any const pointer, passed to the callback visitor function
        -:  121:// @param user_var_p            any pointer, passed to the callback visitor function
        -:  122:// @param block_ix              reported block index where match was found
        -:  123:// @param lu_entry              reported look up index where match was found
function spiffs_obj_lu_find_entry_visitor called 100 returned 100% blocks executed 78%
      100:  124:s32_t spiffs_obj_lu_find_entry_visitor(
        -:  125:    spiffs *fs,
        -:  126:    spiffs_block_ix starting_block,
        -:  127:    int starting_lu_entry,
        -:  128:    u8_t flags,
        -:  129:    spiffs_obj_id obj_id,
        -:  130:    spiffs_visitor_f v,
        -:  131:    const void *user_const_p,
        -:  132:    void *user_var_p,
        -:  133:    spiffs_block_ix *block_ix,
        -:  134:    int *lu_entry) {
      100:  135:  s32_t res = SPIFFS_OK;
      100:  136:  s32_t entry_count = fs->block_count * SPIFFS_OBJ_LOOKUP_MAX_ENTRIES(fs);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      100:  137:  spiffs_block_ix cur_block = starting_block;
      100:  138:  u32_t cur_block_addr = starting_block * SPIFFS_CFG_LOG_BLOCK_SZ(fs);
        -:  139:
      100:  140:  spiffs_obj_id *obj_lu_buf = (spiffs_obj_id *)fs->lu_work;
      100:  141:  int cur_entry = starting_lu_entry;
      100:  142:  int entries_per_page = (SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(spiffs_obj_id));
        -:  143:
        -:  144:  // wrap initial
      100:  145:  if (cur_entry >= (int)SPIFFS_OBJ_LOOKUP_MAX_ENTRIES(fs) - 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  146:    cur_entry = 0;
    #####:  147:    cur_block++;
    #####:  148:    cur_block_addr = cur_block * SPIFFS_CFG_LOG_BLOCK_SZ(fs);
    #####:  149:    if (cur_block >= fs->block_count) {
branch  0 never executed
branch  1 never executed
    #####:  150:      if (flags & SPIFFS_VIS_NO_WRAP) {
branch  0 never executed
branch  1 never executed
    #####:  151:        return SPIFFS_VIS_END;
        -:  152:      } else {
        -:  153:        // block wrap
    #####:  154:        cur_block = 0;
    #####:  155:        cur_block_addr = 0;
        -:  156:      }
        -:  157:    }
        -:  158:  }
        -:  159:
        -:  160:  // check each block
      596:  161:  while (res == SPIFFS_OK && entry_count > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 91%
branch  3 taken 9% (fallthrough)
      450:  162:    int obj_lookup_page = cur_entry / entries_per_page;
        -:  163:    // check each object lookup page
     1300:  164:    while (res == SPIFFS_OK && obj_lookup_page < (int)SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 53%
branch  5 taken 47% (fallthrough)
      450:  165:      int entry_offset = obj_lookup_page * entries_per_page;
      450:  166:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 returned 100%
        -:  167:          0, cur_block_addr + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
        -:  168:      // check each entry
    13382:  169:      while (res == SPIFFS_OK &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
    12932:  170:          cur_entry - entry_offset < entries_per_page && // for non-last obj lookup pages
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
     6466:  171:          cur_entry < (int)SPIFFS_OBJ_LOOKUP_MAX_ENTRIES(fs)) // for last obj lookup page
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:      {
     6066:  173:        if ((flags & SPIFFS_VIS_CHECK_ID) == 0 || obj_lu_buf[cur_entry-entry_offset] == obj_id) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 57% (fallthrough)
branch  3 taken 43%
     6043:  174:          if (block_ix) *block_ix = cur_block;
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
     6043:  175:          if (lu_entry) *lu_entry = cur_entry;
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
     6043:  176:          if (v) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
    18036:  177:            res = v(
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  178:                fs,
    12024:  179:                (flags & SPIFFS_VIS_CHECK_PH) ? obj_id : obj_lu_buf[cur_entry-entry_offset],
        -:  180:                cur_block,
        -:  181:                cur_entry,
        -:  182:                user_const_p,
        -:  183:                user_var_p);
     6012:  184:            if (res == SPIFFS_VIS_COUNTINUE || res == SPIFFS_VIS_COUNTINUE_RELOAD) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
     5993:  185:              if (res == SPIFFS_VIS_COUNTINUE_RELOAD) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  186:                res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  187:                    0, cur_block_addr + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
    #####:  188:                SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  189:              }
     5993:  190:              res = SPIFFS_OK;
     5993:  191:              cur_entry++;
     5993:  192:              entry_count--;
     5993:  193:              continue;
        -:  194:            } else {
       19:  195:              return res;
        -:  196:            }
        -:  197:          } else {
       31:  198:            return SPIFFS_OK;
        -:  199:          }
        -:  200:        }
       23:  201:        entry_count--;
       23:  202:        cur_entry++;
        -:  203:      } // per entry
      400:  204:      obj_lookup_page++;
        -:  205:    } // per object lookup page
      400:  206:    cur_entry = 0;
      400:  207:    cur_block++;
      400:  208:    cur_block_addr += SPIFFS_CFG_LOG_BLOCK_SZ(fs);
      400:  209:    if (cur_block >= fs->block_count) {
branch  0 taken 13% (fallthrough)
branch  1 taken 88%
       50:  210:      if (flags & SPIFFS_VIS_NO_WRAP) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        4:  211:        return SPIFFS_VIS_END;
        -:  212:      } else {
        -:  213:        // block wrap
       46:  214:        cur_block = 0;
       46:  215:        cur_block_addr = 0;
        -:  216:      }
        -:  217:    }
        -:  218:  } // per block
        -:  219:
       46:  220:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  221:
       46:  222:  return SPIFFS_VIS_END;
        -:  223:}
        -:  224:
        -:  225:#if !SPIFFS_READ_ONLY
function spiffs_erase_block called 80 returned 100% blocks executed 76%
       80:  226:s32_t spiffs_erase_block(
        -:  227:    spiffs *fs,
        -:  228:    spiffs_block_ix bix) {
        -:  229:  s32_t res;
       80:  230:  u32_t addr = SPIFFS_BLOCK_TO_PADDR(fs, bix);
       80:  231:  s32_t size = SPIFFS_CFG_LOG_BLOCK_SZ(fs);
        -:  232:
        -:  233:  // here we ignore res, just try erasing the block
      320:  234:  while (size > 0) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  235:    SPIFFS_DBG("erase %08x:%08x\n", addr,  SPIFFS_CFG_PHYS_ERASE_SZ(fs));
      160:  236:    SPIFFS_HAL_ERASE(fs, addr, SPIFFS_CFG_PHYS_ERASE_SZ(fs));
call    0 returned 100%
        -:  237:
      160:  238:    addr += SPIFFS_CFG_PHYS_ERASE_SZ(fs);
      160:  239:    size -= SPIFFS_CFG_PHYS_ERASE_SZ(fs);
        -:  240:  }
       80:  241:  fs->free_blocks++;
        -:  242:
        -:  243:  // register erase count for this block
       80:  244:  res = _spiffs_wr(fs, SPIFFS_OP_C_WRTHRU | SPIFFS_OP_T_OBJ_LU2, 0,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  245:      SPIFFS_ERASE_COUNT_PADDR(fs, bix),
        -:  246:      sizeof(spiffs_obj_id), (u8_t *)&fs->max_erase_count);
       80:  247:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  248:
        -:  249:#if SPIFFS_USE_MAGIC
        -:  250:  // finally, write magic
       80:  251:  spiffs_obj_id magic = SPIFFS_MAGIC(fs, bix);
       80:  252:  res = _spiffs_wr(fs, SPIFFS_OP_C_WRTHRU | SPIFFS_OP_T_OBJ_LU2, 0,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  253:      SPIFFS_MAGIC_PADDR(fs, bix),
        -:  254:      sizeof(spiffs_obj_id), (u8_t *)&magic);
       80:  255:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  256:#endif
        -:  257:
       80:  258:  fs->max_erase_count++;
       80:  259:  if (fs->max_erase_count == SPIFFS_OBJ_ID_IX_FLAG) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  260:    fs->max_erase_count = 0;
        -:  261:  }
        -:  262:
       80:  263:  return res;
        -:  264:}
        -:  265:#endif // !SPIFFS_READ_ONLY
        -:  266:
        -:  267:#if SPIFFS_USE_MAGIC && SPIFFS_USE_MAGIC_LENGTH && SPIFFS_SINGLETON==0
        -:  268:s32_t spiffs_probe(
        -:  269:    spiffs_config *cfg) {
        -:  270:  s32_t res;
        -:  271:  u32_t paddr;
        -:  272:  spiffs dummy_fs; // create a dummy fs struct just to be able to use macros
        -:  273:  memcpy(&dummy_fs.cfg, cfg, sizeof(spiffs_config));
        -:  274:  dummy_fs.block_count = 0;
        -:  275:
        -:  276:  // Read three magics, as one block may be in an aborted erase state.
        -:  277:  // At least two of these must contain magic and be in decreasing order.
        -:  278:  spiffs_obj_id magic[3];
        -:  279:  spiffs_obj_id bix_count[3];
        -:  280:
        -:  281:  spiffs_block_ix bix;
        -:  282:  for (bix = 0; bix < 3; bix++) {
        -:  283:    paddr = SPIFFS_MAGIC_PADDR(&dummy_fs, bix);
        -:  284:#if SPIFFS_HAL_CALLBACK_EXTRA
        -:  285:    // not any proper fs to report here, so callback with null
        -:  286:    // (cross fingers that no-one gets angry)
        -:  287:    res = cfg->hal_read_f((void *)0, paddr, sizeof(spiffs_obj_id), (u8_t *)&magic[bix]);
        -:  288:#else
        -:  289:    res = cfg->hal_read_f(paddr, sizeof(spiffs_obj_id), (u8_t *)&magic[bix]);
        -:  290:#endif
        -:  291:    bix_count[bix] = magic[bix] ^ SPIFFS_MAGIC(&dummy_fs, 0);
        -:  292:    SPIFFS_CHECK_RES(res);
        -:  293:  }
        -:  294:
        -:  295:  // check that we have sane number of blocks
        -:  296:  if (bix_count[0] < 3) return SPIFFS_ERR_PROBE_TOO_FEW_BLOCKS;
        -:  297:  // check that the order is correct, take aborted erases in calculation
        -:  298:  // first block aborted erase
        -:  299:  if (magic[0] == (spiffs_obj_id)(-1) && bix_count[1] - bix_count[2] == 1) {
        -:  300:    return (bix_count[1]+1) * cfg->log_block_size;
        -:  301:  }
        -:  302:  // second block aborted erase
        -:  303:  if (magic[1] == (spiffs_obj_id)(-1) && bix_count[0] - bix_count[2] == 2) {
        -:  304:    return bix_count[0] * cfg->log_block_size;
        -:  305:  }
        -:  306:  // third block aborted erase
        -:  307:  if (magic[2] == (spiffs_obj_id)(-1) && bix_count[0] - bix_count[1] == 1) {
        -:  308:    return bix_count[0] * cfg->log_block_size;
        -:  309:  }
        -:  310:  // no block has aborted erase
        -:  311:  if (bix_count[0] - bix_count[1] == 1 && bix_count[1] - bix_count[2] == 1) {
        -:  312:    return bix_count[0] * cfg->log_block_size;
        -:  313:  }
        -:  314:
        -:  315:  return SPIFFS_ERR_PROBE_NOT_A_FS;
        -:  316:}
        -:  317:#endif // SPIFFS_USE_MAGIC && SPIFFS_USE_MAGIC_LENGTH && SPIFFS_SINGLETON==0
        -:  318:
        -:  319:
function spiffs_obj_lu_scan_v called 1440 returned 100% blocks executed 89%
     1440:  320:static s32_t spiffs_obj_lu_scan_v(
        -:  321:    spiffs *fs,
        -:  322:    spiffs_obj_id obj_id,
        -:  323:    spiffs_block_ix bix,
        -:  324:    int ix_entry,
        -:  325:    const void *user_const_p,
        -:  326:    void *user_var_p) {
        -:  327:  (void)bix;
        -:  328:  (void)user_const_p;
        -:  329:  (void)user_var_p;
     1440:  330:  if (obj_id == SPIFFS_OBJ_ID_FREE) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     1434:  331:    if (ix_entry == 0) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
       94:  332:      fs->free_blocks++;
        -:  333:      // todo optimize further, return SPIFFS_NEXT_BLOCK
        -:  334:    }
        6:  335:  } else if (obj_id == SPIFFS_OBJ_ID_DELETED) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  336:    fs->stats_p_deleted++;
        -:  337:  } else {
        6:  338:    fs->stats_p_allocated++;
        -:  339:  }
        -:  340:
     1440:  341:  return SPIFFS_VIS_COUNTINUE;
        -:  342:}
        -:  343:
        -:  344:
        -:  345:// Scans thru all obj lu and counts free, deleted and used pages
        -:  346:// Find the maximum block erase count
        -:  347:// Checks magic if enabled
function spiffs_obj_lu_scan called 21 returned 100% blocks executed 75%
       21:  348:s32_t spiffs_obj_lu_scan(
        -:  349:    spiffs *fs) {
        -:  350:  s32_t res;
        -:  351:  spiffs_block_ix bix;
        -:  352:  int entry;
        -:  353:#if SPIFFS_USE_MAGIC
       21:  354:  spiffs_block_ix unerased_bix = (spiffs_block_ix)-1;
        -:  355:#endif
        -:  356:
        -:  357:  // find out erase count
        -:  358:  // if enabled, check magic
       21:  359:  bix = 0;
        -:  360:  spiffs_obj_id erase_count_final;
       21:  361:  spiffs_obj_id erase_count_min = SPIFFS_OBJ_ID_FREE;
       21:  362:  spiffs_obj_id erase_count_max = 0;
      147:  363:  while (bix < fs->block_count) {
branch  0 taken 90%
branch  1 taken 10% (fallthrough)
        -:  364:#if SPIFFS_USE_MAGIC
        -:  365:    spiffs_obj_id magic;
      114:  366:    res = _spiffs_rd(fs,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  367:        SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
        -:  368:        0, SPIFFS_MAGIC_PADDR(fs, bix) ,
        -:  369:        sizeof(spiffs_obj_id), (u8_t *)&magic);
        -:  370:
      123:  371:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      114:  372:    if (magic != SPIFFS_MAGIC(fs, bix)) {
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
       18:  373:      if (unerased_bix == (spiffs_block_ix)-1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  374:        // allow one unerased block as it might be powered down during an erase
        9:  375:        unerased_bix = bix;
        -:  376:      } else {
        -:  377:        // more than one unerased block, bail out
        9:  378:        SPIFFS_CHECK_RES(SPIFFS_ERR_NOT_A_FS);
        -:  379:      }
        -:  380:    }
        -:  381:#endif
        -:  382:    spiffs_obj_id erase_count;
      105:  383:    res = _spiffs_rd(fs,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  384:        SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
        -:  385:        0, SPIFFS_ERASE_COUNT_PADDR(fs, bix) ,
        -:  386:        sizeof(spiffs_obj_id), (u8_t *)&erase_count);
      105:  387:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      105:  388:    if (erase_count != SPIFFS_OBJ_ID_FREE) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
       96:  389:      erase_count_min = MIN(erase_count_min, erase_count);
       96:  390:      erase_count_max = MAX(erase_count_max, erase_count);
        -:  391:    }
      105:  392:    bix++;
        -:  393:  }
        -:  394:
       12:  395:  if (erase_count_min == 0 && erase_count_max == SPIFFS_OBJ_ID_FREE) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  396:    // clean system, set counter to zero
    #####:  397:    erase_count_final = 0;
       12:  398:  } else if (erase_count_max - erase_count_min > (SPIFFS_OBJ_ID_FREE)/2) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  399:    // wrap, take min
    #####:  400:    erase_count_final = erase_count_min+1;
        -:  401:  } else {
       12:  402:    erase_count_final = erase_count_max+1;
        -:  403:  }
        -:  404:
       12:  405:  fs->max_erase_count = erase_count_final;
        -:  406:
        -:  407:#if SPIFFS_USE_MAGIC
       12:  408:  if (unerased_bix != (spiffs_block_ix)-1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  409:    // found one unerased block, remedy
        -:  410:    SPIFFS_DBG("mount: erase block %i\n", bix);
        -:  411:#if SPIFFS_READ_ONLY
        -:  412:    res = SPIFFS_ERR_RO_ABORTED_OPERATION;
        -:  413:#else
    #####:  414:    res = spiffs_erase_block(fs, unerased_bix);
call    0 never executed
        -:  415:#endif // SPIFFS_READ_ONLY
    #####:  416:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  417:  }
        -:  418:#endif
        -:  419:
        -:  420:  // count blocks
        -:  421:
       12:  422:  fs->free_blocks = 0;
       12:  423:  fs->stats_p_allocated = 0;
       12:  424:  fs->stats_p_deleted = 0;
        -:  425:
       12:  426:  res = spiffs_obj_lu_find_entry_visitor(fs,
call    0 returned 100%
        -:  427:      0,
        -:  428:      0,
        -:  429:      0,
        -:  430:      0,
        -:  431:      spiffs_obj_lu_scan_v,
        -:  432:      0,
        -:  433:      0,
        -:  434:      &bix,
        -:  435:      &entry);
        -:  436:
       12:  437:  if (res == SPIFFS_VIS_END) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  438:    res = SPIFFS_OK;
        -:  439:  }
        -:  440:
       12:  441:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  442:
       12:  443:  return res;
        -:  444:}
        -:  445:
        -:  446:#if !SPIFFS_READ_ONLY
        -:  447:// Find free object lookup entry
        -:  448:// Iterate over object lookup pages in each block until a free object id entry is found
function spiffs_obj_lu_find_free called 31 returned 100% blocks executed 56%
       31:  449:s32_t spiffs_obj_lu_find_free(
        -:  450:    spiffs *fs,
        -:  451:    spiffs_block_ix starting_block,
        -:  452:    int starting_lu_entry,
        -:  453:    spiffs_block_ix *block_ix,
        -:  454:    int *lu_entry) {
        -:  455:  s32_t res;
       31:  456:  if (!fs->cleaning && fs->free_blocks < 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  457:    res = spiffs_gc_quick(fs, 0);
call    0 never executed
    #####:  458:    if (res == SPIFFS_ERR_NO_DELETED_BLOCKS) {
branch  0 never executed
branch  1 never executed
    #####:  459:      res = SPIFFS_OK;
        -:  460:    }
    #####:  461:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  462:    if (fs->free_blocks < 2) {
branch  0 never executed
branch  1 never executed
    #####:  463:      return SPIFFS_ERR_FULL;
        -:  464:    }
        -:  465:  }
       31:  466:  res = spiffs_obj_lu_find_id(fs, starting_block, starting_lu_entry,
call    0 returned 100%
        -:  467:      SPIFFS_OBJ_ID_FREE, block_ix, lu_entry);
       31:  468:  if (res == SPIFFS_OK) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       31:  469:    fs->free_cursor_block_ix = *block_ix;
       31:  470:    fs->free_cursor_obj_lu_entry = *lu_entry;
       31:  471:    if (*lu_entry == 0) {
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
        8:  472:      fs->free_blocks--;
        -:  473:    }
        -:  474:  }
        -:  475:  if (res == SPIFFS_ERR_FULL) {
        -:  476:    SPIFFS_DBG("fs full\n");
        -:  477:  }
        -:  478:
       31:  479:  return res;
        -:  480:}
        -:  481:#endif // !SPIFFS_READ_ONLY
        -:  482:
        -:  483:// Find object lookup entry containing given id
        -:  484:// Iterate over object lookup pages in each block until a given object id entry is found
function spiffs_obj_lu_find_id called 31 returned 100% blocks executed 80%
       31:  485:s32_t spiffs_obj_lu_find_id(
        -:  486:    spiffs *fs,
        -:  487:    spiffs_block_ix starting_block,
        -:  488:    int starting_lu_entry,
        -:  489:    spiffs_obj_id obj_id,
        -:  490:    spiffs_block_ix *block_ix,
        -:  491:    int *lu_entry) {
       31:  492:  s32_t res = spiffs_obj_lu_find_entry_visitor(
call    0 returned 100%
        -:  493:      fs, starting_block, starting_lu_entry, SPIFFS_VIS_CHECK_ID, obj_id, 0, 0, 0, block_ix, lu_entry);
       31:  494:  if (res == SPIFFS_VIS_END) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  495:    res = SPIFFS_ERR_NOT_FOUND;
        -:  496:  }
       31:  497:  return res;
        -:  498:}
        -:  499:
        -:  500:
function spiffs_obj_lu_find_id_and_span_v called 0 returned 0% blocks executed 0%
    #####:  501:static s32_t spiffs_obj_lu_find_id_and_span_v(
        -:  502:    spiffs *fs,
        -:  503:    spiffs_obj_id obj_id,
        -:  504:    spiffs_block_ix bix,
        -:  505:    int ix_entry,
        -:  506:    const void *user_const_p,
        -:  507:    void *user_var_p) {
        -:  508:  s32_t res;
        -:  509:  spiffs_page_header ph;
    #####:  510:  spiffs_page_ix pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, ix_entry);
branch  0 never executed
branch  1 never executed
    #####:  511:  res = _spiffs_rd(fs, 0, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -:  512:      SPIFFS_PAGE_TO_PADDR(fs, pix), sizeof(spiffs_page_header), (u8_t *)&ph);
    #####:  513:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  514:  if (ph.obj_id == obj_id &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  515:      ph.span_ix == *((spiffs_span_ix*)user_var_p) &&
branch  0 never executed
branch  1 never executed
    #####:  516:      (ph.flags & (SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_USED)) == SPIFFS_PH_FLAG_DELET &&
branch  0 never executed
branch  1 never executed
    #####:  517:      !((obj_id & SPIFFS_OBJ_ID_IX_FLAG) && (ph.flags & SPIFFS_PH_FLAG_IXDELE) == 0 && ph.span_ix == 0) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  518:      (user_const_p == 0 || *((const spiffs_page_ix*)user_const_p) != pix)) {
branch  0 never executed
branch  1 never executed
    #####:  519:    return SPIFFS_OK;
        -:  520:  } else {
    #####:  521:    return SPIFFS_VIS_COUNTINUE;
        -:  522:  }
        -:  523:}
        -:  524:
        -:  525:// Find object lookup entry containing given id and span index
        -:  526:// Iterate over object lookup pages in each block until a given object id entry is found
function spiffs_obj_lu_find_id_and_span called 0 returned 0% blocks executed 0%
    #####:  527:s32_t spiffs_obj_lu_find_id_and_span(
        -:  528:    spiffs *fs,
        -:  529:    spiffs_obj_id obj_id,
        -:  530:    spiffs_span_ix spix,
        -:  531:    spiffs_page_ix exclusion_pix,
        -:  532:    spiffs_page_ix *pix) {
        -:  533:  s32_t res;
        -:  534:  spiffs_block_ix bix;
        -:  535:  int entry;
        -:  536:
    #####:  537:  res = spiffs_obj_lu_find_entry_visitor(fs,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  538:      fs->cursor_block_ix,
        -:  539:      fs->cursor_obj_lu_entry,
        -:  540:      SPIFFS_VIS_CHECK_ID,
        -:  541:      obj_id,
        -:  542:      spiffs_obj_lu_find_id_and_span_v,
    #####:  543:      exclusion_pix ? &exclusion_pix : 0,
        -:  544:      &spix,
        -:  545:      &bix,
        -:  546:      &entry);
        -:  547:
    #####:  548:  if (res == SPIFFS_VIS_END) {
branch  0 never executed
branch  1 never executed
    #####:  549:    res = SPIFFS_ERR_NOT_FOUND;
        -:  550:  }
        -:  551:
    #####:  552:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  553:
    #####:  554:  if (pix) {
branch  0 never executed
branch  1 never executed
    #####:  555:    *pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 never executed
branch  1 never executed
        -:  556:  }
        -:  557:
    #####:  558:  fs->cursor_block_ix = bix;
    #####:  559:  fs->cursor_obj_lu_entry = entry;
        -:  560:
    #####:  561:  return res;
        -:  562:}
        -:  563:
        -:  564:// Find object lookup entry containing given id and span index in page headers only
        -:  565:// Iterate over object lookup pages in each block until a given object id entry is found
function spiffs_obj_lu_find_id_and_span_by_phdr called 0 returned 0% blocks executed 0%
    #####:  566:s32_t spiffs_obj_lu_find_id_and_span_by_phdr(
        -:  567:    spiffs *fs,
        -:  568:    spiffs_obj_id obj_id,
        -:  569:    spiffs_span_ix spix,
        -:  570:    spiffs_page_ix exclusion_pix,
        -:  571:    spiffs_page_ix *pix) {
        -:  572:  s32_t res;
        -:  573:  spiffs_block_ix bix;
        -:  574:  int entry;
        -:  575:
    #####:  576:  res = spiffs_obj_lu_find_entry_visitor(fs,
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  577:      fs->cursor_block_ix,
        -:  578:      fs->cursor_obj_lu_entry,
        -:  579:      SPIFFS_VIS_CHECK_PH,
        -:  580:      obj_id,
        -:  581:      spiffs_obj_lu_find_id_and_span_v,
    #####:  582:      exclusion_pix ? &exclusion_pix : 0,
        -:  583:      &spix,
        -:  584:      &bix,
        -:  585:      &entry);
        -:  586:
    #####:  587:  if (res == SPIFFS_VIS_END) {
branch  0 never executed
branch  1 never executed
    #####:  588:    res = SPIFFS_ERR_NOT_FOUND;
        -:  589:  }
        -:  590:
    #####:  591:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  592:
    #####:  593:  if (pix) {
branch  0 never executed
branch  1 never executed
    #####:  594:    *pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 never executed
branch  1 never executed
        -:  595:  }
        -:  596:
    #####:  597:  fs->cursor_block_ix = bix;
    #####:  598:  fs->cursor_obj_lu_entry = entry;
        -:  599:
    #####:  600:  return res;
        -:  601:}
        -:  602:
        -:  603:#if !SPIFFS_READ_ONLY
        -:  604:// Allocates a free defined page with given obj_id
        -:  605:// Occupies object lookup entry and page
        -:  606:// data may be NULL; where only page header is stored, len and page_offs is ignored
function spiffs_page_allocate_data called 13 returned 100% blocks executed 63%
       13:  607:s32_t spiffs_page_allocate_data(
        -:  608:    spiffs *fs,
        -:  609:    spiffs_obj_id obj_id,
        -:  610:    spiffs_page_header *ph,
        -:  611:    u8_t *data,
        -:  612:    u32_t len,
        -:  613:    u32_t page_offs,
        -:  614:    u8_t finalize,
        -:  615:    spiffs_page_ix *pix) {
       13:  616:  s32_t res = SPIFFS_OK;
        -:  617:  spiffs_block_ix bix;
        -:  618:  int entry;
        -:  619:
        -:  620:  // find free entry
       13:  621:  res = spiffs_obj_lu_find_free(fs, fs->free_cursor_block_ix, fs->free_cursor_obj_lu_entry, &bix, &entry);
call    0 returned 100%
       13:  622:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  623:
        -:  624:  // occupy page in object lookup
       13:  625:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -:  626:      0, SPIFFS_BLOCK_TO_PADDR(fs, bix) + entry * sizeof(spiffs_obj_id), sizeof(spiffs_obj_id), (u8_t*)&obj_id);
       13:  627:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  628:
       13:  629:  fs->stats_p_allocated++;
        -:  630:
        -:  631:  // write page header
       13:  632:  ph->flags &= ~SPIFFS_PH_FLAG_USED;
       13:  633:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  634:      0, SPIFFS_OBJ_LOOKUP_ENTRY_TO_PADDR(fs, bix, entry), sizeof(spiffs_page_header), (u8_t*)ph);
       13:  635:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  636:
        -:  637:  // write page data
       13:  638:  if (data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:  639:    res = _spiffs_wr(fs,  SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  640:        0,SPIFFS_OBJ_LOOKUP_ENTRY_TO_PADDR(fs, bix, entry) + sizeof(spiffs_page_header) + page_offs, len, data);
       13:  641:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  642:  }
        -:  643:
        -:  644:  // finalize header if necessary
       13:  645:  if (finalize && (ph->flags & SPIFFS_PH_FLAG_FINAL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  646:    ph->flags &= ~SPIFFS_PH_FLAG_FINAL;
    #####:  647:    res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  648:        0, SPIFFS_OBJ_LOOKUP_ENTRY_TO_PADDR(fs, bix, entry) + offsetof(spiffs_page_header, flags),
        -:  649:        sizeof(u8_t),
        -:  650:        (u8_t *)&ph->flags);
    #####:  651:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  652:  }
        -:  653:
        -:  654:  // return written page
       13:  655:  if (pix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:  656:    *pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  657:  }
        -:  658:
       13:  659:  return res;
        -:  660:}
        -:  661:#endif // !SPIFFS_READ_ONLY
        -:  662:
        -:  663:#if !SPIFFS_READ_ONLY
        -:  664:// Moves a page from src to a free page and finalizes it. Updates page index. Page data is given in param page.
        -:  665:// If page data is null, provided header is used for metainfo and page data is physically copied.
function spiffs_page_move called 1 returned 100% blocks executed 73%
        1:  666:s32_t spiffs_page_move(
        -:  667:    spiffs *fs,
        -:  668:    spiffs_file fh,
        -:  669:    u8_t *page_data,
        -:  670:    spiffs_obj_id obj_id,
        -:  671:    spiffs_page_header *page_hdr,
        -:  672:    spiffs_page_ix src_pix,
        -:  673:    spiffs_page_ix *dst_pix) {
        -:  674:  s32_t res;
        1:  675:  u8_t was_final = 0;
        -:  676:  spiffs_page_header *p_hdr;
        -:  677:  spiffs_block_ix bix;
        -:  678:  int entry;
        -:  679:  spiffs_page_ix free_pix;
        -:  680:
        -:  681:  // find free entry
        1:  682:  res = spiffs_obj_lu_find_free(fs, fs->free_cursor_block_ix, fs->free_cursor_obj_lu_entry, &bix, &entry);
call    0 returned 100%
        1:  683:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        1:  684:  free_pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  685:
        1:  686:  if (dst_pix) *dst_pix = free_pix;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  687:
        1:  688:  p_hdr = page_data ? (spiffs_page_header *)page_data : page_hdr;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  689:  if (page_data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  690:    // got page data
        1:  691:    was_final = (p_hdr->flags & SPIFFS_PH_FLAG_FINAL) == 0;
        -:  692:    // write unfinalized page
        1:  693:    p_hdr->flags |= SPIFFS_PH_FLAG_FINAL;
        1:  694:    p_hdr->flags &= ~SPIFFS_PH_FLAG_USED;
        1:  695:    res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -:  696:        0, SPIFFS_PAGE_TO_PADDR(fs, free_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), page_data);
        -:  697:  } else {
        -:  698:    // copy page data
    #####:  699:    res = spiffs_phys_cpy(fs, fh, SPIFFS_PAGE_TO_PADDR(fs, free_pix), SPIFFS_PAGE_TO_PADDR(fs, src_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs));
call    0 never executed
        -:  700:  }
        1:  701:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  702:
        -:  703:  // mark entry in destination object lookup
        1:  704:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_UPDT,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  705:      0, SPIFFS_BLOCK_TO_PADDR(fs, SPIFFS_BLOCK_FOR_PAGE(fs, free_pix)) + SPIFFS_OBJ_LOOKUP_ENTRY_FOR_PAGE(fs, free_pix) * sizeof(spiffs_page_ix),
        -:  706:      sizeof(spiffs_obj_id),
        -:  707:      (u8_t *)&obj_id);
        1:  708:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  709:
        1:  710:  fs->stats_p_allocated++;
        -:  711:
        1:  712:  if (was_final) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  713:    // mark finalized in destination page
        1:  714:    p_hdr->flags &= ~(SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_USED);
        1:  715:    res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -:  716:        fh,
        -:  717:        SPIFFS_PAGE_TO_PADDR(fs, free_pix) + offsetof(spiffs_page_header, flags),
        -:  718:        sizeof(u8_t),
        -:  719:        (u8_t *)&p_hdr->flags);
        1:  720:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  721:  }
        -:  722:  // mark source deleted
        1:  723:  res = spiffs_page_delete(fs, src_pix);
call    0 returned 100%
        1:  724:  return res;
        -:  725:}
        -:  726:#endif // !SPIFFS_READ_ONLY
        -:  727:
        -:  728:#if !SPIFFS_READ_ONLY
        -:  729:// Deletes a page and removes it from object lookup.
function spiffs_page_delete called 1 returned 100% blocks executed 80%
        1:  730:s32_t spiffs_page_delete(
        -:  731:    spiffs *fs,
        -:  732:    spiffs_page_ix pix) {
        -:  733:  s32_t res;
        -:  734:  spiffs_page_header hdr;
        1:  735:  hdr.flags = 0xff & ~(SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_USED);
        -:  736:  // mark deleted entry in source object lookup
        1:  737:  spiffs_obj_id d_obj_id = SPIFFS_OBJ_ID_DELETED;
        1:  738:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_DELE,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  739:      0,
        -:  740:      SPIFFS_BLOCK_TO_PADDR(fs, SPIFFS_BLOCK_FOR_PAGE(fs, pix)) + SPIFFS_OBJ_LOOKUP_ENTRY_FOR_PAGE(fs, pix) * sizeof(spiffs_page_ix),
        -:  741:      sizeof(spiffs_obj_id),
        -:  742:      (u8_t *)&d_obj_id);
        1:  743:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  744:
        1:  745:  fs->stats_p_deleted++;
        1:  746:  fs->stats_p_allocated--;
        -:  747:
        -:  748:  // mark deleted in source page
        1:  749:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_DELE,
call    0 returned 100%
        -:  750:      0,
        -:  751:      SPIFFS_PAGE_TO_PADDR(fs, pix) + offsetof(spiffs_page_header, flags),
        -:  752:      sizeof(u8_t),
        -:  753:      (u8_t *)&hdr.flags);
        -:  754:
        1:  755:  return res;
        -:  756:}
        -:  757:#endif // !SPIFFS_READ_ONLY
        -:  758:
        -:  759:#if !SPIFFS_READ_ONLY
        -:  760:// Create an object index header page with empty index and undefined length
function spiffs_object_create called 17 returned 100% blocks executed 74%
       17:  761:s32_t spiffs_object_create(
        -:  762:    spiffs *fs,
        -:  763:    spiffs_obj_id obj_id,
        -:  764:    const u8_t name[SPIFFS_OBJ_NAME_LEN],
        -:  765:    spiffs_obj_type type,
        -:  766:    spiffs_page_ix *objix_hdr_pix) {
       17:  767:  s32_t res = SPIFFS_OK;
        -:  768:  spiffs_block_ix bix;
        -:  769:  spiffs_page_object_ix_header oix_hdr;
        -:  770:  int entry;
        -:  771:
       17:  772:  res = spiffs_gc_check(fs, SPIFFS_DATA_PAGE_SIZE(fs));
call    0 returned 100%
       17:  773:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  774:
       17:  775:  obj_id |= SPIFFS_OBJ_ID_IX_FLAG;
        -:  776:
        -:  777:  // find free entry
       17:  778:  res = spiffs_obj_lu_find_free(fs, fs->free_cursor_block_ix, fs->free_cursor_obj_lu_entry, &bix, &entry);
call    0 returned 100%
       17:  779:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  780:  SPIFFS_DBG("create: found free page @ %04x bix:%i entry:%i\n", SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry), bix, entry);
        -:  781:
        -:  782:  // occupy page in object lookup
       17:  783:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -:  784:      0, SPIFFS_BLOCK_TO_PADDR(fs, bix) + entry * sizeof(spiffs_obj_id), sizeof(spiffs_obj_id), (u8_t*)&obj_id);
       17:  785:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  786:
       17:  787:  fs->stats_p_allocated++;
        -:  788:
        -:  789:  // write empty object index page
       17:  790:  oix_hdr.p_hdr.obj_id = obj_id;
       17:  791:  oix_hdr.p_hdr.span_ix = 0;
       17:  792:  oix_hdr.p_hdr.flags = 0xff & ~(SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_INDEX | SPIFFS_PH_FLAG_USED);
       17:  793:  oix_hdr.type = type;
       17:  794:  oix_hdr.size = SPIFFS_UNDEFINED_LEN; // keep ones so we can update later without wasting this page
       17:  795:  strncpy((char*)&oix_hdr.name, (const char*)name, SPIFFS_OBJ_NAME_LEN);
        -:  796:
        -:  797:
        -:  798:  // update page
       17:  799:  res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  800:      0, SPIFFS_OBJ_LOOKUP_ENTRY_TO_PADDR(fs, bix, entry), sizeof(spiffs_page_object_ix_header), (u8_t*)&oix_hdr);
        -:  801:
       17:  802:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       17:  803:  spiffs_cb_object_event(fs, 0, SPIFFS_EV_IX_NEW, obj_id, 0, SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry), SPIFFS_UNDEFINED_LEN);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 returned 100%
        -:  804:
       17:  805:  if (objix_hdr_pix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       17:  806:    *objix_hdr_pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  807:  }
        -:  808:
       17:  809:  return res;
        -:  810:}
        -:  811:#endif // !SPIFFS_READ_ONLY
        -:  812:
        -:  813:#if !SPIFFS_READ_ONLY
        -:  814:// update object index header with any combination of name/size/index
        -:  815:// new_objix_hdr_data may be null, if so the object index header page is loaded
        -:  816:// name may be null, if so name is not changed
        -:  817:// size may be null, if so size is not changed
function spiffs_object_update_index_hdr called 1 returned 100% blocks executed 66%
        1:  818:s32_t spiffs_object_update_index_hdr(
        -:  819:    spiffs *fs,
        -:  820:    spiffs_fd *fd,
        -:  821:    spiffs_obj_id obj_id,
        -:  822:    spiffs_page_ix objix_hdr_pix,
        -:  823:    u8_t *new_objix_hdr_data,
        -:  824:    const u8_t name[SPIFFS_OBJ_NAME_LEN],
        -:  825:    u32_t size,
        -:  826:    spiffs_page_ix *new_pix) {
        1:  827:  s32_t res = SPIFFS_OK;
        -:  828:  spiffs_page_object_ix_header *objix_hdr;
        -:  829:  spiffs_page_ix new_objix_hdr_pix;
        -:  830:
        1:  831:  obj_id |=  SPIFFS_OBJ_ID_IX_FLAG;
        -:  832:
        1:  833:  if (new_objix_hdr_data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  834:    // object index header page already given to us, no need to load it
        1:  835:    objix_hdr = (spiffs_page_object_ix_header *)new_objix_hdr_data;
        -:  836:  } else {
        -:  837:    // read object index header page
    #####:  838:    res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 never executed
        -:  839:        fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, objix_hdr_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####:  840:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  841:    objix_hdr = (spiffs_page_object_ix_header *)fs->work;
        -:  842:  }
        -:  843:
        1:  844:  SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, obj_id, 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
        -:  845:
        -:  846:  // change name
        1:  847:  if (name) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  848:    strncpy((char*)objix_hdr->name, (const char*)name, SPIFFS_OBJ_NAME_LEN);
        -:  849:  }
        1:  850:  if (size) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  851:    objix_hdr->size = size;
        -:  852:  }
        -:  853:
        -:  854:  // move and update page
        1:  855:  res = spiffs_page_move(fs, fd == 0 ? 0 : fd->file_nbr, (u8_t*)objix_hdr, obj_id, 0, objix_hdr_pix, &new_objix_hdr_pix);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  856:
        1:  857:  if (res == SPIFFS_OK) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  858:    if (new_pix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  859:      *new_pix = new_objix_hdr_pix;
        -:  860:    }
        -:  861:    // callback on object index update
        1:  862:    spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, obj_id, objix_hdr->p_hdr.span_ix, new_objix_hdr_pix, objix_hdr->size);
call    0 returned 100%
        1:  863:    if (fd) fd->objix_hdr_pix = new_objix_hdr_pix; // if this is not in the registered cluster
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  864:  }
        -:  865:
        1:  866:  return res;
        -:  867:}
        -:  868:#endif // !SPIFFS_READ_ONLY
        -:  869:
function spiffs_cb_object_event called 31 returned 100% blocks executed 58%
       31:  870:void spiffs_cb_object_event(
        -:  871:    spiffs *fs,
        -:  872:    spiffs_fd *fd,
        -:  873:    int ev,
        -:  874:    spiffs_obj_id obj_id_raw,
        -:  875:    spiffs_span_ix spix,
        -:  876:    spiffs_page_ix new_pix,
        -:  877:    u32_t new_size) {
        -:  878:  (void)fd;
        -:  879:  // update index caches in all file descriptors
       31:  880:  spiffs_obj_id obj_id = obj_id_raw & ~SPIFFS_OBJ_ID_IX_FLAG;
        -:  881:  u32_t i;
       31:  882:  spiffs_fd *fds = (spiffs_fd *)fs->fd_space;
      186:  883:  for (i = 0; i < fs->fd_count; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      155:  884:    spiffs_fd *cur_fd = &fds[i];
      155:  885:    if (cur_fd->file_nbr == 0 || (cur_fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG) != obj_id) continue;
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
branch  2 taken 55% (fallthrough)
branch  3 taken 45%
       14:  886:    if (spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  887:      if (ev == SPIFFS_EV_IX_NEW || ev == SPIFFS_EV_IX_UPD) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  888:        SPIFFS_DBG("       callback: setting fd %i:%04x objix_hdr_pix to %04x, size:%i\n", cur_fd->file_nbr, cur_fd->obj_id, new_pix, new_size);
       14:  889:        cur_fd->objix_hdr_pix = new_pix;
       28:  890:        if (new_size != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  891:          cur_fd->size = new_size;
        -:  892:        }
    #####:  893:      } else if (ev == SPIFFS_EV_IX_DEL) {
branch  0 never executed
branch  1 never executed
    #####:  894:        cur_fd->file_nbr = 0;
    #####:  895:        cur_fd->obj_id = SPIFFS_OBJ_ID_DELETED;
        -:  896:      }
        -:  897:    }
       14:  898:    if (cur_fd->cursor_objix_spix == spix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       14:  899:      if (ev == SPIFFS_EV_IX_NEW || ev == SPIFFS_EV_IX_UPD) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  900:        SPIFFS_DBG("       callback: setting fd %i:%04x span:%04x objix_pix to %04x\n", cur_fd->file_nbr, cur_fd->obj_id, spix, new_pix);
       14:  901:        cur_fd->cursor_objix_pix = new_pix;
        -:  902:      } else {
    #####:  903:        cur_fd->cursor_objix_pix = 0;
        -:  904:      }
        -:  905:    }
        -:  906:  }
        -:  907:
        -:  908:  // callback to user if object index header
       31:  909:  if (fs->file_cb_f && spix == 0 && (obj_id_raw & SPIFFS_OBJ_ID_IX_FLAG)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  910:    spiffs_fileop_type op;
    #####:  911:    if (ev == SPIFFS_EV_IX_NEW) {
branch  0 never executed
branch  1 never executed
    #####:  912:      op = SPIFFS_CB_CREATED;
    #####:  913:    } else if (ev == SPIFFS_EV_IX_UPD) {
branch  0 never executed
branch  1 never executed
    #####:  914:      op = SPIFFS_CB_UPDATED;
    #####:  915:    } else if (ev == SPIFFS_EV_IX_DEL) {
branch  0 never executed
branch  1 never executed
    #####:  916:      op = SPIFFS_CB_DELETED;
        -:  917:    } else {
        -:  918:      SPIFFS_DBG("       callback: WARNING unknown callback event %02x\n", ev);
    #####:  919:      return; // bail out
        -:  920:    }
    #####:  921:    fs->file_cb_f(fs, op, obj_id, new_pix);
call    0 never executed
        -:  922:  }
        -:  923:}
        -:  924:
        -:  925:// Open object by id
function spiffs_object_open_by_id called 0 returned 0% blocks executed 0%
    #####:  926:s32_t spiffs_object_open_by_id(
        -:  927:    spiffs *fs,
        -:  928:    spiffs_obj_id obj_id,
        -:  929:    spiffs_fd *fd,
        -:  930:    spiffs_flags flags,
        -:  931:    spiffs_mode mode) {
    #####:  932:  s32_t res = SPIFFS_OK;
        -:  933:  spiffs_page_ix pix;
        -:  934:
    #####:  935:  res = spiffs_obj_lu_find_id_and_span(fs, obj_id | SPIFFS_OBJ_ID_IX_FLAG, 0, 0, &pix);
call    0 never executed
    #####:  936:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  937:
    #####:  938:  res = spiffs_object_open_by_page(fs, pix, fd, flags, mode);
call    0 never executed
        -:  939:
    #####:  940:  return res;
        -:  941:}
        -:  942:
        -:  943:// Open object by page index
function spiffs_object_open_by_page called 23 returned 100% blocks executed 64%
       23:  944:s32_t spiffs_object_open_by_page(
        -:  945:    spiffs *fs,
        -:  946:    spiffs_page_ix pix,
        -:  947:    spiffs_fd *fd,
        -:  948:    spiffs_flags flags,
        -:  949:    spiffs_mode mode) {
        -:  950:  (void)mode;
       23:  951:  s32_t res = SPIFFS_OK;
        -:  952:  spiffs_page_object_ix_header oix_hdr;
        -:  953:  spiffs_obj_id obj_id;
        -:  954:
       23:  955:  res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 returned 100%
        -:  956:      fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, pix), sizeof(spiffs_page_object_ix_header), (u8_t *)&oix_hdr);
       23:  957:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  958:
       23:  959:  spiffs_block_ix bix = SPIFFS_BLOCK_FOR_PAGE(fs, pix);
       23:  960:  int entry = SPIFFS_OBJ_LOOKUP_ENTRY_FOR_PAGE(fs, pix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  961:
       23:  962:  res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 returned 100%
        -:  963:      0,  SPIFFS_BLOCK_TO_PADDR(fs, bix) + entry * sizeof(spiffs_obj_id), sizeof(spiffs_obj_id), (u8_t *)&obj_id);
        -:  964:
       23:  965:  fd->fs = fs;
       23:  966:  fd->objix_hdr_pix = pix;
       23:  967:  fd->size = oix_hdr.size;
       23:  968:  fd->offset = 0;
       23:  969:  fd->cursor_objix_pix = pix;
       23:  970:  fd->cursor_objix_spix = 0;
       23:  971:  fd->obj_id = obj_id;
       23:  972:  fd->flags = flags;
        -:  973:
       23:  974:  SPIFFS_VALIDATE_OBJIX(oix_hdr.p_hdr, fd->obj_id, 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
        -:  975:
        -:  976:  SPIFFS_DBG("open: fd %i is obj id %04x\n", fd->file_nbr, fd->obj_id);
        -:  977:
       23:  978:  return res;
        -:  979:}
        -:  980:
        -:  981:#if !SPIFFS_READ_ONLY
        -:  982:// Append to object
        -:  983:// keep current object index (header) page in fs->work buffer
function spiffs_object_append called 14 returned 100% blocks executed 33%
       14:  984:s32_t spiffs_object_append(spiffs_fd *fd, u32_t offset, u8_t *data, u32_t len) {
       14:  985:  spiffs *fs = fd->fs;
       14:  986:  s32_t res = SPIFFS_OK;
       14:  987:  u32_t written = 0;
        -:  988:
        -:  989:  SPIFFS_DBG("append: %i bytes @ offs %i of size %i\n", len, offset, fd->size);
        -:  990:
       14:  991:  if (offset > fd->size) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  992:    SPIFFS_DBG("append: offset reversed to size\n");
    #####:  993:    offset = fd->size;
        -:  994:  }
        -:  995:
       14:  996:  res = spiffs_gc_check(fs, len + SPIFFS_DATA_PAGE_SIZE(fs)); // add an extra page of data worth for meta
call    0 returned 100%
        -:  997:  if (res != SPIFFS_OK) {
        -:  998:    SPIFFS_DBG("append: gc check fail %i\n", res);
        -:  999:  }
       14: 1000:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1001:
       14: 1002:  spiffs_page_object_ix_header *objix_hdr = (spiffs_page_object_ix_header *)fs->work;
       14: 1003:  spiffs_page_object_ix *objix = (spiffs_page_object_ix *)fs->work;
        -: 1004:  spiffs_page_header p_hdr;
        -: 1005:
       14: 1006:  spiffs_span_ix cur_objix_spix = 0;
       14: 1007:  spiffs_span_ix prev_objix_spix = (spiffs_span_ix)-1;
       14: 1008:  spiffs_page_ix cur_objix_pix = fd->objix_hdr_pix;
        -: 1009:  spiffs_page_ix new_objix_hdr_page;
        -: 1010:
       14: 1011:  spiffs_span_ix data_spix = offset / SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1012:  spiffs_page_ix data_page;
       14: 1013:  u32_t page_offs = offset % SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1014:
        -: 1015:  // write all data
       42: 1016:  while (res == SPIFFS_OK && written < len) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50%
branch  3 taken 50% (fallthrough)
        -: 1017:    // calculate object index page span index
       14: 1018:    cur_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, data_spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1019:
        -: 1020:    // handle storing and loading of object indices
       14: 1021:    if (cur_objix_spix != prev_objix_spix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1022:      // new object index page
        -: 1023:      // within this clause we return directly if something fails, object index mess-up
       14: 1024:      if (written > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1025:        // store previous object index page, unless first pass
        -: 1026:        SPIFFS_DBG("append: %04x store objix %04x:%04x, written %i\n", fd->obj_id,
        -: 1027:            cur_objix_pix, prev_objix_spix, written);
    #####: 1028:        if (prev_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1029:          // this is an update to object index header page
    #####: 1030:          objix_hdr->size = offset+written;
    #####: 1031:          if (offset == 0) {
branch  0 never executed
branch  1 never executed
        -: 1032:            // was an empty object, update same page (size was 0xffffffff)
    #####: 1033:            res = spiffs_page_index_check(fs, fd, cur_objix_pix, 0);
call    0 never executed
    #####: 1034:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1035:            res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1036:                fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1037:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1038:          } else {
        -: 1039:            // was a nonempty object, update to new page
    #####: 1040:            res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1041:                fd->objix_hdr_pix, fs->work, 0, offset+written, &new_objix_hdr_page);
    #####: 1042:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1043:            SPIFFS_DBG("append: %04x store new objix_hdr, %04x:%04x, written %i\n", fd->obj_id,
        -: 1044:                new_objix_hdr_page, 0, written);
        -: 1045:          }
        -: 1046:        } else {
        -: 1047:          // this is an update to an object index page
    #####: 1048:          res = spiffs_page_index_check(fs, fd, cur_objix_pix, prev_objix_spix);
call    0 never executed
    #####: 1049:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1050:
    #####: 1051:          res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1052:              fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1053:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1054:          spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD,fd->obj_id, objix->p_hdr.span_ix, cur_objix_pix, 0);
call    0 never executed
        -: 1055:          // update length in object index header page
    #####: 1056:          res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1057:              fd->objix_hdr_pix, 0, 0, offset+written, &new_objix_hdr_page);
    #####: 1058:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1059:          SPIFFS_DBG("append: %04x store new size I %i in objix_hdr, %04x:%04x, written %i\n", fd->obj_id,
        -: 1060:              offset+written, new_objix_hdr_page, 0, written);
        -: 1061:        }
    #####: 1062:        fd->size = offset+written;
    #####: 1063:        fd->offset = offset+written;
        -: 1064:      }
        -: 1065:
        -: 1066:      // create or load new object index page
       14: 1067:      if (cur_objix_spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1068:        // load object index header page, must always exist
        -: 1069:        SPIFFS_DBG("append: %04x load objixhdr page %04x:%04x\n", fd->obj_id, cur_objix_pix, cur_objix_spix);
       14: 1070:        res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 returned 100%
        -: 1071:            fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
       14: 1072:        SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       14: 1073:        SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
        -: 1074:      } else {
    #####: 1075:        spiffs_span_ix len_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, (fd->size-1)/SPIFFS_DATA_PAGE_SIZE(fs));
branch  0 never executed
branch  1 never executed
        -: 1076:        // on subsequent passes, create a new object index page
    #####: 1077:        if (written > 0 || cur_objix_spix > len_objix_spix) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1078:          p_hdr.obj_id = fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG;
    #####: 1079:          p_hdr.span_ix = cur_objix_spix;
    #####: 1080:          p_hdr.flags = 0xff & ~(SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_INDEX);
    #####: 1081:          res = spiffs_page_allocate_data(fs, fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG,
call    0 never executed
        -: 1082:              &p_hdr, 0, 0, 0, 1, &cur_objix_pix);
    #####: 1083:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1084:          spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_NEW, fd->obj_id, cur_objix_spix, cur_objix_pix, 0);
call    0 never executed
        -: 1085:          // quick "load" of new object index page
    #####: 1086:          memset(fs->work, 0xff, SPIFFS_CFG_LOG_PAGE_SZ(fs));
    #####: 1087:          memcpy(fs->work, &p_hdr, sizeof(spiffs_page_header));
        -: 1088:          SPIFFS_DBG("append: %04x create objix page, %04x:%04x, written %i\n", fd->obj_id
        -: 1089:              , cur_objix_pix, cur_objix_spix, written);
        -: 1090:        } else {
        -: 1091:          // on first pass, we load existing object index page
        -: 1092:          spiffs_page_ix pix;
        -: 1093:          SPIFFS_DBG("append: %04x find objix span_ix:%04x\n", fd->obj_id, cur_objix_spix);
    #####: 1094:          if (fd->cursor_objix_spix == cur_objix_spix) {
branch  0 never executed
branch  1 never executed
    #####: 1095:            pix = fd->cursor_objix_pix;
        -: 1096:          } else {
    #####: 1097:            res = spiffs_obj_lu_find_id_and_span(fs, fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG, cur_objix_spix, 0, &pix);
call    0 never executed
    #####: 1098:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1099:          }
        -: 1100:          SPIFFS_DBG("append: %04x found object index at page %04x [fd size %i]\n", fd->obj_id, pix, fd->size);
    #####: 1101:          res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 never executed
        -: 1102:              fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1103:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1104:          SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 1105:          cur_objix_pix = pix;
        -: 1106:        }
    #####: 1107:        fd->cursor_objix_pix = cur_objix_pix;
    #####: 1108:        fd->cursor_objix_spix = cur_objix_spix;
    #####: 1109:        fd->offset = offset+written;
    #####: 1110:        fd->size = offset+written;
        -: 1111:      }
       14: 1112:      prev_objix_spix = cur_objix_spix;
        -: 1113:    }
        -: 1114:
        -: 1115:    // write data
       14: 1116:    u32_t to_write = MIN(len-written, SPIFFS_DATA_PAGE_SIZE(fs) - page_offs);
       14: 1117:    if (page_offs == 0) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -: 1118:      // at beginning of a page, allocate and write a new page of data
       13: 1119:      p_hdr.obj_id = fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG;
       13: 1120:      p_hdr.span_ix = data_spix;
       13: 1121:      p_hdr.flags = 0xff & ~(SPIFFS_PH_FLAG_FINAL);  // finalize immediately
       13: 1122:      res = spiffs_page_allocate_data(fs, fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG,
call    0 returned 100%
        -: 1123:          &p_hdr, &data[written], to_write, page_offs, 1, &data_page);
        -: 1124:      SPIFFS_DBG("append: %04x store new data page, %04x:%04x offset:%i, len %i, written %i\n", fd->obj_id,
        -: 1125:          data_page, data_spix, page_offs, to_write, written);
        -: 1126:    } else {
        -: 1127:      // append to existing page, fill out free data in existing page
        1: 1128:      if (cur_objix_spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1129:        // get data page from object index header page
        1: 1130:        data_page = ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix];
        -: 1131:      } else {
        -: 1132:        // get data page from object index page
    #####: 1133:        data_page = ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)];
branch  0 never executed
branch  1 never executed
        -: 1134:      }
        -: 1135:
        1: 1136:      res = spiffs_page_data_check(fs, fd, data_page, data_spix);
call    0 returned 100%
        1: 1137:      SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1138:
        1: 1139:      res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -: 1140:          fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, data_page) + sizeof(spiffs_page_header) + page_offs, to_write, &data[written]);
        -: 1141:      SPIFFS_DBG("append: %04x store to existing data page, %04x:%04x offset:%i, len %i, written %i\n", fd->obj_id
        -: 1142:          , data_page, data_spix, page_offs, to_write, written);
        -: 1143:    }
        -: 1144:
       14: 1145:    if (res != SPIFFS_OK) break;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1146:
        -: 1147:    // update memory representation of object index page with new data page
       14: 1148:    if (cur_objix_spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1149:      // update object index header page
       14: 1150:      ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix] = data_page;
        -: 1151:      SPIFFS_DBG("append: %04x wrote page %04x to objix_hdr entry %02x in mem\n", fd->obj_id
        -: 1152:          , data_page, data_spix);
       14: 1153:      objix_hdr->size = offset+written;
        -: 1154:    } else {
        -: 1155:      // update object index page
    #####: 1156:      ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)] = data_page;
branch  0 never executed
branch  1 never executed
        -: 1157:      SPIFFS_DBG("append: %04x wrote page %04x to objix entry %02x in mem\n", fd->obj_id
        -: 1158:          , data_page, SPIFFS_OBJ_IX_ENTRY(fs, data_spix));
        -: 1159:    }
        -: 1160:
        -: 1161:    // update internals
       14: 1162:    page_offs = 0;
       14: 1163:    data_spix++;
       14: 1164:    written += to_write;
        -: 1165:  } // while all data
        -: 1166:
       14: 1167:  fd->size = offset+written;
       14: 1168:  fd->offset = offset+written;
       14: 1169:  fd->cursor_objix_pix = cur_objix_pix;
       14: 1170:  fd->cursor_objix_spix = cur_objix_spix;
        -: 1171:
        -: 1172:  // finalize updated object indices
       14: 1173:  s32_t res2 = SPIFFS_OK;
       14: 1174:  if (cur_objix_spix != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1175:    // wrote beyond object index header page
        -: 1176:    // write last modified object index page, unless object header index page
        -: 1177:    SPIFFS_DBG("append: %04x store objix page, %04x:%04x, written %i\n", fd->obj_id,
        -: 1178:        cur_objix_pix, cur_objix_spix, written);
        -: 1179:
    #####: 1180:    res2 = spiffs_page_index_check(fs, fd, cur_objix_pix, cur_objix_spix);
call    0 never executed
    #####: 1181:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
        -: 1182:
    #####: 1183:    res2 = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1184:        fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1185:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
    #####: 1186:    spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, fd->obj_id, objix->p_hdr.span_ix, cur_objix_pix, 0);
call    0 never executed
        -: 1187:
        -: 1188:    // update size in object header index page
    #####: 1189:    res2 = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1190:        fd->objix_hdr_pix, 0, 0, offset+written, &new_objix_hdr_page);
        -: 1191:    SPIFFS_DBG("append: %04x store new size II %i in objix_hdr, %04x:%04x, written %i, res %i\n", fd->obj_id
        -: 1192:        , offset+written, new_objix_hdr_page, 0, written, res2);
    #####: 1193:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
        -: 1194:  } else {
        -: 1195:    // wrote within object index header page
       14: 1196:    if (offset == 0) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -: 1197:      // wrote to empty object - simply update size and write whole page
       13: 1198:      objix_hdr->size = offset+written;
        -: 1199:      SPIFFS_DBG("append: %04x store fresh objix_hdr page, %04x:%04x, written %i\n", fd->obj_id
        -: 1200:          , cur_objix_pix, cur_objix_spix, written);
        -: 1201:
       13: 1202:      res2 = spiffs_page_index_check(fs, fd, cur_objix_pix, cur_objix_spix);
call    0 returned 100%
       13: 1203:      SPIFFS_CHECK_RES(res2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1204:
       13: 1205:      res2 = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_UPDT,
call    0 returned 100%
        -: 1206:          fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
       13: 1207:      SPIFFS_CHECK_RES(res2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1208:      // callback on object index update
       13: 1209:      spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, fd->obj_id, objix_hdr->p_hdr.span_ix, cur_objix_pix, objix_hdr->size);
call    0 returned 100%
        -: 1210:    } else {
        -: 1211:      // modifying object index header page, update size and make new copy
        2: 1212:      res2 = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 returned 100%
        1: 1213:          fd->objix_hdr_pix, fs->work, 0, offset+written, &new_objix_hdr_page);
        -: 1214:      SPIFFS_DBG("append: %04x store modified objix_hdr page, %04x:%04x, written %i\n", fd->obj_id
        -: 1215:          , new_objix_hdr_page, 0, written);
        1: 1216:      SPIFFS_CHECK_RES(res2);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1217:    }
        -: 1218:  }
        -: 1219:
       14: 1220:  return res;
        -: 1221:} // spiffs_object_append
        -: 1222:#endif // !SPIFFS_READ_ONLY
        -: 1223:
        -: 1224:#if !SPIFFS_READ_ONLY
        -: 1225:// Modify object
        -: 1226:// keep current object index (header) page in fs->work buffer
function spiffs_object_modify called 0 returned 0% blocks executed 0%
    #####: 1227:s32_t spiffs_object_modify(spiffs_fd *fd, u32_t offset, u8_t *data, u32_t len) {
    #####: 1228:  spiffs *fs = fd->fs;
    #####: 1229:  s32_t res = SPIFFS_OK;
    #####: 1230:  u32_t written = 0;
        -: 1231:
    #####: 1232:  res = spiffs_gc_check(fs, len + SPIFFS_DATA_PAGE_SIZE(fs));
call    0 never executed
    #####: 1233:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1234:
    #####: 1235:  spiffs_page_object_ix_header *objix_hdr = (spiffs_page_object_ix_header *)fs->work;
    #####: 1236:  spiffs_page_object_ix *objix = (spiffs_page_object_ix *)fs->work;
        -: 1237:  spiffs_page_header p_hdr;
        -: 1238:
    #####: 1239:  spiffs_span_ix cur_objix_spix = 0;
    #####: 1240:  spiffs_span_ix prev_objix_spix = (spiffs_span_ix)-1;
    #####: 1241:  spiffs_page_ix cur_objix_pix = fd->objix_hdr_pix;
        -: 1242:  spiffs_page_ix new_objix_hdr_pix;
        -: 1243:
    #####: 1244:  spiffs_span_ix data_spix = offset / SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1245:  spiffs_page_ix data_pix;
    #####: 1246:  u32_t page_offs = offset % SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1247:
        -: 1248:
        -: 1249:  // write all data
    #####: 1250:  while (res == SPIFFS_OK && written < len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1251:    // calculate object index page span index
    #####: 1252:    cur_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, data_spix);
branch  0 never executed
branch  1 never executed
        -: 1253:
        -: 1254:    // handle storing and loading of object indices
    #####: 1255:    if (cur_objix_spix != prev_objix_spix) {
branch  0 never executed
branch  1 never executed
        -: 1256:      // new object index page
        -: 1257:      // within this clause we return directly if something fails, object index mess-up
    #####: 1258:      if (written > 0) {
branch  0 never executed
branch  1 never executed
        -: 1259:        // store previous object index (header) page, unless first pass
    #####: 1260:        if (prev_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1261:          // store previous object index header page
    #####: 1262:          res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1263:              fd->objix_hdr_pix, fs->work, 0, 0, &new_objix_hdr_pix);
        -: 1264:          SPIFFS_DBG("modify: store modified objix_hdr page, %04x:%04x, written %i\n", new_objix_hdr_pix, 0, written);
    #####: 1265:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1266:        } else {
        -: 1267:          // store new version of previous object index page
        -: 1268:          spiffs_page_ix new_objix_pix;
        -: 1269:
    #####: 1270:          res = spiffs_page_index_check(fs, fd, cur_objix_pix, prev_objix_spix);
call    0 never executed
    #####: 1271:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1272:
    #####: 1273:          res = spiffs_page_move(fs, fd->file_nbr, (u8_t*)objix, fd->obj_id, 0, cur_objix_pix, &new_objix_pix);
call    0 never executed
        -: 1274:          SPIFFS_DBG("modify: store previous modified objix page, %04x:%04x, written %i\n", new_objix_pix, objix->p_hdr.span_ix, written);
    #####: 1275:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1276:          spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, fd->obj_id, objix->p_hdr.span_ix, new_objix_pix, 0);
call    0 never executed
        -: 1277:        }
        -: 1278:      }
        -: 1279:
        -: 1280:      // load next object index page
    #####: 1281:      if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1282:        // load object index header page, must exist
        -: 1283:        SPIFFS_DBG("modify: load objixhdr page %04x:%04x\n", cur_objix_pix, cur_objix_spix);
    #####: 1284:        res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 never executed
        -: 1285:            fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, cur_objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1286:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1287:        SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
        -: 1288:      } else {
        -: 1289:        // load existing object index page on first pass
        -: 1290:        spiffs_page_ix pix;
        -: 1291:        SPIFFS_DBG("modify: find objix span_ix:%04x\n", cur_objix_spix);
    #####: 1292:        if (fd->cursor_objix_spix == cur_objix_spix) {
branch  0 never executed
branch  1 never executed
    #####: 1293:          pix = fd->cursor_objix_pix;
        -: 1294:        } else {
    #####: 1295:          res = spiffs_obj_lu_find_id_and_span(fs, fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG, cur_objix_spix, 0, &pix);
call    0 never executed
    #####: 1296:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1297:        }
        -: 1298:        SPIFFS_DBG("modify: found object index at page %04x\n", pix);
    #####: 1299:        res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 never executed
        -: 1300:            fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1301:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1302:        SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 1303:        cur_objix_pix = pix;
        -: 1304:      }
    #####: 1305:      fd->cursor_objix_pix = cur_objix_pix;
    #####: 1306:      fd->cursor_objix_spix = cur_objix_spix;
    #####: 1307:      fd->offset = offset+written;
    #####: 1308:      prev_objix_spix = cur_objix_spix;
        -: 1309:    }
        -: 1310:
        -: 1311:    // write partial data
    #####: 1312:    u32_t to_write = MIN(len-written, SPIFFS_DATA_PAGE_SIZE(fs) - page_offs);
        -: 1313:    spiffs_page_ix orig_data_pix;
    #####: 1314:    if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1315:      // get data page from object index header page
    #####: 1316:      orig_data_pix = ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix];
        -: 1317:    } else {
        -: 1318:      // get data page from object index page
    #####: 1319:      orig_data_pix = ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)];
branch  0 never executed
branch  1 never executed
        -: 1320:    }
        -: 1321:
    #####: 1322:    p_hdr.obj_id = fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG;
    #####: 1323:    p_hdr.span_ix = data_spix;
    #####: 1324:    p_hdr.flags = 0xff;
    #####: 1325:    if (page_offs == 0 && to_write == SPIFFS_DATA_PAGE_SIZE(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1326:      // a full page, allocate and write a new page of data
    #####: 1327:      res = spiffs_page_allocate_data(fs, fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG,
call    0 never executed
        -: 1328:          &p_hdr, &data[written], to_write, page_offs, 1, &data_pix);
        -: 1329:      SPIFFS_DBG("modify: store new data page, %04x:%04x offset:%i, len %i, written %i\n", data_pix, data_spix, page_offs, to_write, written);
        -: 1330:    } else {
        -: 1331:      // write to existing page, allocate new and copy unmodified data
        -: 1332:
    #####: 1333:      res = spiffs_page_data_check(fs, fd, orig_data_pix, data_spix);
call    0 never executed
    #####: 1334:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1335:
    #####: 1336:      res = spiffs_page_allocate_data(fs, fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG,
call    0 never executed
        -: 1337:          &p_hdr, 0, 0, 0, 0, &data_pix);
    #####: 1338:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1339:
        -: 1340:      // copy unmodified data
    #####: 1341:      if (page_offs > 0) {
branch  0 never executed
branch  1 never executed
        -: 1342:        // before modification
    #####: 1343:        res = spiffs_phys_cpy(fs, fd->file_nbr,
call    0 never executed
    #####: 1344:            SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header),
    #####: 1345:            SPIFFS_PAGE_TO_PADDR(fs, orig_data_pix) + sizeof(spiffs_page_header),
        -: 1346:            page_offs);
    #####: 1347:        if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1348:      }
    #####: 1349:      if (page_offs + to_write < SPIFFS_DATA_PAGE_SIZE(fs)) {
branch  0 never executed
branch  1 never executed
        -: 1350:        // after modification
    #####: 1351:        res = spiffs_phys_cpy(fs, fd->file_nbr,
call    0 never executed
    #####: 1352:            SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header) + page_offs + to_write,
    #####: 1353:            SPIFFS_PAGE_TO_PADDR(fs, orig_data_pix) + sizeof(spiffs_page_header) + page_offs + to_write,
    #####: 1354:            SPIFFS_DATA_PAGE_SIZE(fs) - (page_offs + to_write));
    #####: 1355:        if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1356:      }
        -: 1357:
    #####: 1358:      res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1359:          fd->file_nbr,
        -: 1360:          SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header) + page_offs, to_write, &data[written]);
    #####: 1361:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
    #####: 1362:      p_hdr.flags &= ~SPIFFS_PH_FLAG_FINAL;
    #####: 1363:      res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1364:          fd->file_nbr,
        -: 1365:          SPIFFS_PAGE_TO_PADDR(fs, data_pix) + offsetof(spiffs_page_header, flags),
        -: 1366:          sizeof(u8_t),
        -: 1367:          (u8_t *)&p_hdr.flags);
    #####: 1368:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1369:
        -: 1370:      SPIFFS_DBG("modify: store to existing data page, src:%04x, dst:%04x:%04x offset:%i, len %i, written %i\n", orig_data_pix, data_pix, data_spix, page_offs, to_write, written);
        -: 1371:    }
        -: 1372:
        -: 1373:    // delete original data page
    #####: 1374:    res = spiffs_page_delete(fs, orig_data_pix);
call    0 never executed
    #####: 1375:    if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1376:    // update memory representation of object index page with new data page
    #####: 1377:    if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1378:      // update object index header page
    #####: 1379:      ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix] = data_pix;
        -: 1380:      SPIFFS_DBG("modify: wrote page %04x to objix_hdr entry %02x in mem\n", data_pix, data_spix);
        -: 1381:    } else {
        -: 1382:      // update object index page
    #####: 1383:      ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)] = data_pix;
branch  0 never executed
branch  1 never executed
        -: 1384:      SPIFFS_DBG("modify: wrote page %04x to objix entry %02x in mem\n", data_pix, SPIFFS_OBJ_IX_ENTRY(fs, data_spix));
        -: 1385:    }
        -: 1386:
        -: 1387:    // update internals
    #####: 1388:    page_offs = 0;
    #####: 1389:    data_spix++;
    #####: 1390:    written += to_write;
        -: 1391:  } // while all data
        -: 1392:
    #####: 1393:  fd->offset = offset+written;
    #####: 1394:  fd->cursor_objix_pix = cur_objix_pix;
    #####: 1395:  fd->cursor_objix_spix = cur_objix_spix;
        -: 1396:
        -: 1397:  // finalize updated object indices
    #####: 1398:  s32_t res2 = SPIFFS_OK;
    #####: 1399:  if (cur_objix_spix != 0) {
branch  0 never executed
branch  1 never executed
        -: 1400:    // wrote beyond object index header page
        -: 1401:    // write last modified object index page
        -: 1402:    // move and update page
        -: 1403:    spiffs_page_ix new_objix_pix;
        -: 1404:
    #####: 1405:    res2 = spiffs_page_index_check(fs, fd, cur_objix_pix, cur_objix_spix);
call    0 never executed
    #####: 1406:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
        -: 1407:
    #####: 1408:    res2 = spiffs_page_move(fs, fd->file_nbr, (u8_t*)objix, fd->obj_id, 0, cur_objix_pix, &new_objix_pix);
call    0 never executed
        -: 1409:    SPIFFS_DBG("modify: store modified objix page, %04x:%04x, written %i\n", new_objix_pix, cur_objix_spix, written);
    #####: 1410:    fd->cursor_objix_pix = new_objix_pix;
    #####: 1411:    fd->cursor_objix_spix = cur_objix_spix;
    #####: 1412:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
    #####: 1413:    spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, fd->obj_id, objix->p_hdr.span_ix, new_objix_pix, 0);
call    0 never executed
        -: 1414:
        -: 1415:  } else {
        -: 1416:    // wrote within object index header page
    #####: 1417:    res2 = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1418:        fd->objix_hdr_pix, fs->work, 0, 0, &new_objix_hdr_pix);
        -: 1419:    SPIFFS_DBG("modify: store modified objix_hdr page, %04x:%04x, written %i\n", new_objix_hdr_pix, 0, written);
    #####: 1420:    SPIFFS_CHECK_RES(res2);
branch  0 never executed
branch  1 never executed
        -: 1421:  }
        -: 1422:
    #####: 1423:  return res;
        -: 1424:} // spiffs_object_modify
        -: 1425:#endif // !SPIFFS_READ_ONLY
        -: 1426:
function spiffs_object_find_object_index_header_by_name_v called 2052 returned 100% blocks executed 88%
     2052: 1427:static s32_t spiffs_object_find_object_index_header_by_name_v(
        -: 1428:    spiffs *fs,
        -: 1429:    spiffs_obj_id obj_id,
        -: 1430:    spiffs_block_ix bix,
        -: 1431:    int ix_entry,
        -: 1432:    const void *user_const_p,
        -: 1433:    void *user_var_p) {
        -: 1434:  (void)user_var_p;
        -: 1435:  s32_t res;
        -: 1436:  spiffs_page_object_ix_header objix_hdr;
     2052: 1437:  spiffs_page_ix pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, ix_entry);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
     2094: 1438:  if (obj_id == SPIFFS_OBJ_ID_FREE || obj_id == SPIFFS_OBJ_ID_DELETED ||
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 98% (fallthrough)
branch  3 taken 2%
branch  4 taken 36% (fallthrough)
branch  5 taken 64%
       42: 1439:      (obj_id & SPIFFS_OBJ_ID_IX_FLAG) == 0) {
     2025: 1440:    return SPIFFS_VIS_COUNTINUE;
        -: 1441:  }
       27: 1442:  res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 returned 100%
        -: 1443:      0, SPIFFS_PAGE_TO_PADDR(fs, pix), sizeof(spiffs_page_object_ix_header), (u8_t *)&objix_hdr);
       27: 1444:  SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       54: 1445:  if (objix_hdr.p_hdr.span_ix == 0 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       27: 1446:      (objix_hdr.p_hdr.flags & (SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_IXDELE)) ==
        -: 1447:          (SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_IXDELE)) {
       27: 1448:    if (strcmp((const char*)user_const_p, (char*)objix_hdr.name) == 0) {
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
        8: 1449:      return SPIFFS_OK;
        -: 1450:    }
        -: 1451:  }
        -: 1452:
       19: 1453:  return SPIFFS_VIS_COUNTINUE;
        -: 1454:}
        -: 1455:
        -: 1456:// Finds object index header page by name
function spiffs_object_find_object_index_header_by_name called 25 returned 100% blocks executed 92%
       25: 1457:s32_t spiffs_object_find_object_index_header_by_name(
        -: 1458:    spiffs *fs,
        -: 1459:    const u8_t name[SPIFFS_OBJ_NAME_LEN],
        -: 1460:    spiffs_page_ix *pix) {
        -: 1461:  s32_t res;
        -: 1462:  spiffs_block_ix bix;
        -: 1463:  int entry;
        -: 1464:
       50: 1465:  res = spiffs_obj_lu_find_entry_visitor(fs,
call    0 returned 100%
       25: 1466:      fs->cursor_block_ix,
        -: 1467:      fs->cursor_obj_lu_entry,
        -: 1468:      0,
        -: 1469:      0,
        -: 1470:      spiffs_object_find_object_index_header_by_name_v,
        -: 1471:      name,
        -: 1472:      0,
        -: 1473:      &bix,
        -: 1474:      &entry);
        -: 1475:
       25: 1476:  if (res == SPIFFS_VIS_END) {
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
       17: 1477:    res = SPIFFS_ERR_NOT_FOUND;
        -: 1478:  }
       25: 1479:  SPIFFS_CHECK_RES(res);
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -: 1480:
        8: 1481:  if (pix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8: 1482:    *pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, entry);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1483:  }
        -: 1484:
        8: 1485:  fs->cursor_block_ix = bix;
        8: 1486:  fs->cursor_obj_lu_entry = entry;
        -: 1487:
        8: 1488:  return res;
        -: 1489:}
        -: 1490:
        -: 1491:#if !SPIFFS_READ_ONLY
        -: 1492:// Truncates object to new size. If new size is null, object may be removed totally
function spiffs_object_truncate called 1 returned 100% blocks executed 3%
        1: 1493:s32_t spiffs_object_truncate(
        -: 1494:    spiffs_fd *fd,
        -: 1495:    u32_t new_size,
        -: 1496:    u8_t remove) {
        1: 1497:  s32_t res = SPIFFS_OK;
        1: 1498:  spiffs *fs = fd->fs;
        -: 1499:
        1: 1500:  if ((fd->size == SPIFFS_UNDEFINED_LEN || fd->size == 0) && !remove) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -: 1501:    // no op
        1: 1502:    return res;
        -: 1503:  }
        -: 1504:
        -: 1505:  // need 2 pages if not removing: object index page + possibly chopped data page
    #####: 1506:  res = spiffs_gc_check(fs, remove ? 0 : SPIFFS_DATA_PAGE_SIZE(fs) * 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1507:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1508:
    #####: 1509:  spiffs_page_ix objix_pix = fd->objix_hdr_pix;
    #####: 1510:  spiffs_span_ix data_spix = (fd->size > 0 ? fd->size-1 : 0) / SPIFFS_DATA_PAGE_SIZE(fs);
branch  0 never executed
branch  1 never executed
    #####: 1511:  u32_t cur_size = fd->size == (u32_t)SPIFFS_UNDEFINED_LEN ? 0 : fd->size ;
branch  0 never executed
branch  1 never executed
    #####: 1512:  spiffs_span_ix cur_objix_spix = 0;
    #####: 1513:  spiffs_span_ix prev_objix_spix = (spiffs_span_ix)-1;
    #####: 1514:  spiffs_page_object_ix_header *objix_hdr = (spiffs_page_object_ix_header *)fs->work;
    #####: 1515:  spiffs_page_object_ix *objix = (spiffs_page_object_ix *)fs->work;
        -: 1516:  spiffs_page_ix data_pix;
        -: 1517:  spiffs_page_ix new_objix_hdr_pix;
        -: 1518:
        -: 1519:  // before truncating, check if object is to be fully removed and mark this
    #####: 1520:  if (remove && new_size == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1521:    u8_t flags = ~( SPIFFS_PH_FLAG_USED | SPIFFS_PH_FLAG_INDEX | SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_IXDELE);
    #####: 1522:    res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1523:        fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, fd->objix_hdr_pix) + offsetof(spiffs_page_header, flags),
        -: 1524:        sizeof(u8_t),
        -: 1525:        (u8_t *)&flags);
    #####: 1526:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1527:  }
        -: 1528:
        -: 1529:  // delete from end of object until desired len is reached
    #####: 1530:  while (cur_size > new_size) {
branch  0 never executed
branch  1 never executed
    #####: 1531:    cur_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, data_spix);
branch  0 never executed
branch  1 never executed
        -: 1532:
        -: 1533:    // put object index for current data span index in work buffer
    #####: 1534:    if (prev_objix_spix != cur_objix_spix) {
branch  0 never executed
branch  1 never executed
    #####: 1535:      if (prev_objix_spix != (spiffs_span_ix)-1) {
branch  0 never executed
branch  1 never executed
        -: 1536:        // remove previous object index page
        -: 1537:        SPIFFS_DBG("truncate: delete objix page %04x:%04x\n", objix_pix, prev_objix_spix);
        -: 1538:
    #####: 1539:        res = spiffs_page_index_check(fs, fd, objix_pix, prev_objix_spix);
call    0 never executed
    #####: 1540:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1541:
    #####: 1542:        res = spiffs_page_delete(fs, objix_pix);
call    0 never executed
    #####: 1543:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1544:        spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_DEL, fd->obj_id, objix->p_hdr.span_ix, objix_pix, 0);
call    0 never executed
    #####: 1545:        if (prev_objix_spix > 0) {
branch  0 never executed
branch  1 never executed
        -: 1546:          // update object index header page
        -: 1547:          SPIFFS_DBG("truncate: update objix hdr page %04x:%04x to size %i\n", fd->objix_hdr_pix, prev_objix_spix, cur_size);
    #####: 1548:          res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1549:              fd->objix_hdr_pix, 0, 0, cur_size, &new_objix_hdr_pix);
    #####: 1550:          SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1551:          fd->size = cur_size;
        -: 1552:        }
        -: 1553:      }
        -: 1554:      // load current object index (header) page
    #####: 1555:      if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1556:        objix_pix = fd->objix_hdr_pix;
        -: 1557:      } else {
    #####: 1558:        res = spiffs_obj_lu_find_id_and_span(fs, fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG, cur_objix_spix, 0, &objix_pix);
call    0 never executed
    #####: 1559:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1560:      }
        -: 1561:
        -: 1562:      SPIFFS_DBG("truncate: load objix page %04x:%04x for data spix:%04x\n", objix_pix, cur_objix_spix, data_spix);
    #####: 1563:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 never executed
        -: 1564:          fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####: 1565:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1566:      SPIFFS_VALIDATE_OBJIX(objix_hdr->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####: 1567:      fd->cursor_objix_pix = objix_pix;
    #####: 1568:      fd->cursor_objix_spix = cur_objix_spix;
    #####: 1569:      fd->offset = cur_size;
        -: 1570:
    #####: 1571:      prev_objix_spix = cur_objix_spix;
        -: 1572:    }
        -: 1573:
    #####: 1574:    if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1575:      // get data page from object index header page
    #####: 1576:      data_pix = ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix];
    #####: 1577:      ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix] = SPIFFS_OBJ_ID_FREE;
        -: 1578:    } else {
        -: 1579:      // get data page from object index page
    #####: 1580:      data_pix = ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)];
branch  0 never executed
branch  1 never executed
    #####: 1581:      ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)] = SPIFFS_OBJ_ID_FREE;
branch  0 never executed
branch  1 never executed
        -: 1582:    }
        -: 1583:
        -: 1584:    SPIFFS_DBG("truncate: got data pix %04x\n", data_pix);
        -: 1585:
    #####: 1586:    if (new_size == 0 || remove || cur_size - new_size >= SPIFFS_DATA_PAGE_SIZE(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1587:      // delete full data page
    #####: 1588:      res = spiffs_page_data_check(fs, fd, data_pix, data_spix);
call    0 never executed
    #####: 1589:      if (res != SPIFFS_ERR_DELETED && res != SPIFFS_OK && res != SPIFFS_ERR_INDEX_REF_FREE) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1590:        SPIFFS_DBG("truncate: err validating data pix %i\n", res);
    #####: 1591:        break;
        -: 1592:      }
        -: 1593:
    #####: 1594:      if (res == SPIFFS_OK) {
branch  0 never executed
branch  1 never executed
    #####: 1595:        res = spiffs_page_delete(fs, data_pix);
call    0 never executed
    #####: 1596:        if (res != SPIFFS_OK) {
branch  0 never executed
branch  1 never executed
        -: 1597:          SPIFFS_DBG("truncate: err deleting data pix %i\n", res);
    #####: 1598:          break;
        -: 1599:        }
    #####: 1600:      } else if (res == SPIFFS_ERR_DELETED || res == SPIFFS_ERR_INDEX_REF_FREE) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1601:        res = SPIFFS_OK;
        -: 1602:      }
        -: 1603:
        -: 1604:      // update current size
    #####: 1605:      if (cur_size % SPIFFS_DATA_PAGE_SIZE(fs) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1606:        cur_size -= SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1607:      } else {
    #####: 1608:        cur_size -= cur_size % SPIFFS_DATA_PAGE_SIZE(fs);
        -: 1609:      }
    #####: 1610:      fd->size = cur_size;
    #####: 1611:      fd->offset = cur_size;
        -: 1612:      SPIFFS_DBG("truncate: delete data page %04x for data spix:%04x, cur_size:%i\n", data_pix, data_spix, cur_size);
        -: 1613:    } else {
        -: 1614:      // delete last page, partially
        -: 1615:      spiffs_page_header p_hdr;
        -: 1616:      spiffs_page_ix new_data_pix;
    #####: 1617:      u32_t bytes_to_remove = SPIFFS_DATA_PAGE_SIZE(fs) - (new_size % SPIFFS_DATA_PAGE_SIZE(fs));
        -: 1618:      SPIFFS_DBG("truncate: delete %i bytes from data page %04x for data spix:%04x, cur_size:%i\n", bytes_to_remove, data_pix, data_spix, cur_size);
        -: 1619:
    #####: 1620:      res = spiffs_page_data_check(fs, fd, data_pix, data_spix);
call    0 never executed
    #####: 1621:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1622:
    #####: 1623:      p_hdr.obj_id = fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG;
    #####: 1624:      p_hdr.span_ix = data_spix;
    #####: 1625:      p_hdr.flags = 0xff;
        -: 1626:      // allocate new page and copy unmodified data
    #####: 1627:      res = spiffs_page_allocate_data(fs, fd->obj_id & ~SPIFFS_OBJ_ID_IX_FLAG,
call    0 never executed
        -: 1628:          &p_hdr, 0, 0, 0, 0, &new_data_pix);
    #####: 1629:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
    #####: 1630:      res = spiffs_phys_cpy(fs, 0,
call    0 never executed
    #####: 1631:          SPIFFS_PAGE_TO_PADDR(fs, new_data_pix) + sizeof(spiffs_page_header),
    #####: 1632:          SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header),
    #####: 1633:          SPIFFS_DATA_PAGE_SIZE(fs) - bytes_to_remove);
    #####: 1634:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1635:      // delete original data page
    #####: 1636:      res = spiffs_page_delete(fs, data_pix);
call    0 never executed
    #####: 1637:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
    #####: 1638:      p_hdr.flags &= ~SPIFFS_PH_FLAG_FINAL;
    #####: 1639:      res = _spiffs_wr(fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_UPDT,
call    0 never executed
        -: 1640:          fd->file_nbr,
        -: 1641:          SPIFFS_PAGE_TO_PADDR(fs, new_data_pix) + offsetof(spiffs_page_header, flags),
        -: 1642:          sizeof(u8_t),
        -: 1643:          (u8_t *)&p_hdr.flags);
    #####: 1644:      if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -: 1645:
        -: 1646:      // update memory representation of object index page with new data page
    #####: 1647:      if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1648:        // update object index header page
    #####: 1649:        ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix] = new_data_pix;
        -: 1650:        SPIFFS_DBG("truncate: wrote page %04x to objix_hdr entry %02x in mem\n", new_data_pix, SPIFFS_OBJ_IX_ENTRY(fs, data_spix));
        -: 1651:      } else {
        -: 1652:        // update object index page
    #####: 1653:        ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)] = new_data_pix;
branch  0 never executed
branch  1 never executed
        -: 1654:        SPIFFS_DBG("truncate: wrote page %04x to objix entry %02x in mem\n", new_data_pix, SPIFFS_OBJ_IX_ENTRY(fs, data_spix));
        -: 1655:      }
    #####: 1656:      cur_size = new_size;
    #####: 1657:      fd->size = new_size;
    #####: 1658:      fd->offset = cur_size;
    #####: 1659:      break;
        -: 1660:    }
    #####: 1661:    data_spix--;
        -: 1662:  } // while all data
        -: 1663:
        -: 1664:  // update object indices
    #####: 1665:  if (cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -: 1666:    // update object index header page
    #####: 1667:    if (cur_size == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1668:      if (remove) {
branch  0 never executed
branch  1 never executed
        -: 1669:        // remove object altogether
        -: 1670:        SPIFFS_DBG("truncate: remove object index header page %04x\n", objix_pix);
        -: 1671:
    #####: 1672:        res = spiffs_page_index_check(fs, fd, objix_pix, 0);
call    0 never executed
    #####: 1673:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1674:
    #####: 1675:        res = spiffs_page_delete(fs, objix_pix);
call    0 never executed
    #####: 1676:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1677:        spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_DEL, fd->obj_id, 0, objix_pix, 0);
call    0 never executed
        -: 1678:      } else {
        -: 1679:        // make uninitialized object
        -: 1680:        SPIFFS_DBG("truncate: reset objix_hdr page %04x\n", objix_pix);
    #####: 1681:        memset(fs->work + sizeof(spiffs_page_object_ix_header), 0xff,
    #####: 1682:            SPIFFS_CFG_LOG_PAGE_SZ(fs) - sizeof(spiffs_page_object_ix_header));
    #####: 1683:        res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
        -: 1684:            objix_pix, fs->work, 0, SPIFFS_UNDEFINED_LEN, &new_objix_hdr_pix);
    #####: 1685:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1686:      }
        -: 1687:    } else {
        -: 1688:      // update object index header page
        -: 1689:      SPIFFS_DBG("truncate: update object index header page with indices and size\n");
    #####: 1690:      res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
        -: 1691:          objix_pix, fs->work, 0, cur_size, &new_objix_hdr_pix);
    #####: 1692:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1693:    }
        -: 1694:  } else {
        -: 1695:    // update both current object index page and object index header page
        -: 1696:    spiffs_page_ix new_objix_pix;
        -: 1697:
    #####: 1698:    res = spiffs_page_index_check(fs, fd, objix_pix, cur_objix_spix);
call    0 never executed
    #####: 1699:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1700:
        -: 1701:    // move and update object index page
    #####: 1702:    res = spiffs_page_move(fs, fd->file_nbr, (u8_t*)objix_hdr, fd->obj_id, 0, objix_pix, &new_objix_pix);
call    0 never executed
    #####: 1703:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1704:    spiffs_cb_object_event(fs, fd, SPIFFS_EV_IX_UPD, fd->obj_id, objix->p_hdr.span_ix, new_objix_pix, 0);
call    0 never executed
        -: 1705:    SPIFFS_DBG("truncate: store modified objix page, %04x:%04x\n", new_objix_pix, cur_objix_spix);
    #####: 1706:    fd->cursor_objix_pix = new_objix_pix;
    #####: 1707:    fd->cursor_objix_spix = cur_objix_spix;
    #####: 1708:    fd->offset = cur_size;
        -: 1709:    // update object index header page with new size
    #####: 1710:    res = spiffs_object_update_index_hdr(fs, fd, fd->obj_id,
call    0 never executed
    #####: 1711:        fd->objix_hdr_pix, 0, 0, cur_size, &new_objix_hdr_pix);
    #####: 1712:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1713:  }
    #####: 1714:  fd->size = cur_size;
        -: 1715:
    #####: 1716:  return res;
        -: 1717:} // spiffs_object_truncate
        -: 1718:#endif // !SPIFFS_READ_ONLY
        -: 1719:
function spiffs_object_read called 16 returned 100% blocks executed 60%
       16: 1720:s32_t spiffs_object_read(
        -: 1721:    spiffs_fd *fd,
        -: 1722:    u32_t offset,
        -: 1723:    u32_t len,
        -: 1724:    u8_t *dst) {
       16: 1725:  s32_t res = SPIFFS_OK;
       16: 1726:  spiffs *fs = fd->fs;
        -: 1727:  spiffs_page_ix objix_pix;
        -: 1728:  spiffs_page_ix data_pix;
       16: 1729:  spiffs_span_ix data_spix = offset / SPIFFS_DATA_PAGE_SIZE(fs);
       16: 1730:  u32_t cur_offset = offset;
        -: 1731:  spiffs_span_ix cur_objix_spix;
       16: 1732:  spiffs_span_ix prev_objix_spix = (spiffs_span_ix)-1;
       16: 1733:  spiffs_page_object_ix_header *objix_hdr = (spiffs_page_object_ix_header *)fs->work;
       16: 1734:  spiffs_page_object_ix *objix = (spiffs_page_object_ix *)fs->work;
        -: 1735:
       48: 1736:  while (cur_offset < offset + len) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
       16: 1737:    cur_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, data_spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16: 1738:    if (prev_objix_spix != cur_objix_spix) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1739:      // load current object index (header) page
       16: 1740:      if (cur_objix_spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       16: 1741:        objix_pix = fd->objix_hdr_pix;
        -: 1742:      } else {
        -: 1743:        SPIFFS_DBG("read: find objix %04x:%04x\n", fd->obj_id, cur_objix_spix);
    #####: 1744:        res = spiffs_obj_lu_find_id_and_span(fs, fd->obj_id | SPIFFS_OBJ_ID_IX_FLAG, cur_objix_spix, 0, &objix_pix);
call    0 never executed
    #####: 1745:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -: 1746:      }
        -: 1747:      SPIFFS_DBG("read: load objix page %04x:%04x for data spix:%04x\n", objix_pix, cur_objix_spix, data_spix);
       16: 1748:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_IX | SPIFFS_OP_C_READ,
call    0 returned 100%
        -: 1749:          fd->file_nbr, SPIFFS_PAGE_TO_PADDR(fs, objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
       16: 1750:      SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16: 1751:      SPIFFS_VALIDATE_OBJIX(objix->p_hdr, fd->obj_id, cur_objix_spix);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
branch 10 taken 0% (fallthrough)
branch 11 taken 100%
        -: 1752:
       16: 1753:      fd->offset = cur_offset;
       16: 1754:      fd->cursor_objix_pix = objix_pix;
       16: 1755:      fd->cursor_objix_spix = cur_objix_spix;
        -: 1756:
       16: 1757:      prev_objix_spix = cur_objix_spix;
        -: 1758:    }
        -: 1759:
       16: 1760:    if (cur_objix_spix == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1761:      // get data page from object index header page
       16: 1762:      data_pix = ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[data_spix];
        -: 1763:    } else {
        -: 1764:      // get data page from object index page
    #####: 1765:      data_pix = ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, data_spix)];
branch  0 never executed
branch  1 never executed
        -: 1766:    }
        -: 1767:
        -: 1768:    // all remaining data
       16: 1769:    u32_t len_to_read = offset + len - cur_offset;
        -: 1770:    // remaining data in page
       16: 1771:    len_to_read = MIN(len_to_read, SPIFFS_DATA_PAGE_SIZE(fs) - (cur_offset % SPIFFS_DATA_PAGE_SIZE(fs)));
        -: 1772:    // remaining data in file
       16: 1773:    len_to_read = MIN(len_to_read, fd->size);
        -: 1774:    SPIFFS_DBG("read: offset:%i rd:%i data spix:%04x is data_pix:%04x addr:%08x\n", cur_offset, len_to_read, data_spix, data_pix,
        -: 1775:        SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header) + (cur_offset % SPIFFS_DATA_PAGE_SIZE(fs)));
       16: 1776:    if (len_to_read <= 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1777:      res = SPIFFS_ERR_END_OF_OBJECT;
    #####: 1778:      break;
        -: 1779:    }
       16: 1780:    res = spiffs_page_data_check(fs, fd, data_pix, data_spix);
call    0 returned 100%
       16: 1781:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16: 1782:    res = _spiffs_rd(
call    0 returned 100%
        -: 1783:        fs, SPIFFS_OP_T_OBJ_DA | SPIFFS_OP_C_READ,
        -: 1784:        fd->file_nbr,
        -: 1785:        SPIFFS_PAGE_TO_PADDR(fs, data_pix) + sizeof(spiffs_page_header) + (cur_offset % SPIFFS_DATA_PAGE_SIZE(fs)),
        -: 1786:        len_to_read,
        -: 1787:        dst);
       16: 1788:    SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       16: 1789:    dst += len_to_read;
       16: 1790:    cur_offset += len_to_read;
       16: 1791:    fd->offset = cur_offset;
       16: 1792:    data_spix++;
        -: 1793:  }
        -: 1794:
       16: 1795:  return res;
        -: 1796:}
        -: 1797:
        -: 1798:#if !SPIFFS_READ_ONLY
        -: 1799:typedef struct {
        -: 1800:  spiffs_obj_id min_obj_id;
        -: 1801:  spiffs_obj_id max_obj_id;
        -: 1802:  u32_t compaction;
        -: 1803:  const u8_t *conflicting_name;
        -: 1804:} spiffs_free_obj_id_state;
        -: 1805:
function spiffs_obj_lu_find_free_obj_id_bitmap_v called 2040 returned 100% blocks executed 38%
     2040: 1806:static s32_t spiffs_obj_lu_find_free_obj_id_bitmap_v(spiffs *fs, spiffs_obj_id id, spiffs_block_ix bix, int ix_entry,
        -: 1807:    const void *user_const_p, void *user_var_p) {
     2040: 1808:  if (id != SPIFFS_OBJ_ID_FREE && id != SPIFFS_OBJ_ID_DELETED) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       31: 1809:    spiffs_obj_id min_obj_id = *((spiffs_obj_id*)user_var_p);
       31: 1810:    const u8_t *conflicting_name = (const u8_t*)user_const_p;
        -: 1811:
        -: 1812:    // if conflicting name parameter is given, also check if this name is found in object index hdrs
       31: 1813:    if (conflicting_name && (id & SPIFFS_OBJ_ID_IX_FLAG)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1814:      spiffs_page_ix pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, ix_entry);
branch  0 never executed
branch  1 never executed
        -: 1815:      int res;
        -: 1816:      spiffs_page_object_ix_header objix_hdr;
    #####: 1817:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -: 1818:          0, SPIFFS_PAGE_TO_PADDR(fs, pix), sizeof(spiffs_page_object_ix_header), (u8_t *)&objix_hdr);
    #####: 1819:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1820:      if (objix_hdr.p_hdr.span_ix == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1821:          (objix_hdr.p_hdr.flags & (SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_IXDELE)) ==
        -: 1822:              (SPIFFS_PH_FLAG_DELET | SPIFFS_PH_FLAG_IXDELE)) {
    #####: 1823:        if (strcmp((const char*)user_const_p, (char*)objix_hdr.name) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1824:          return SPIFFS_ERR_CONFLICTING_NAME;
        -: 1825:        }
        -: 1826:      }
        -: 1827:    }
        -: 1828:
       31: 1829:    id &= ~SPIFFS_OBJ_ID_IX_FLAG;
       31: 1830:    u32_t bit_ix = (id-min_obj_id) & 7;
       31: 1831:    int byte_ix = (id-min_obj_id) >> 3;
       31: 1832:    if (byte_ix >= 0 && (u32_t)byte_ix < SPIFFS_CFG_LOG_PAGE_SZ(fs)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       31: 1833:      fs->work[byte_ix] |= (1<<bit_ix);
        -: 1834:    }
        -: 1835:  }
     2040: 1836:  return SPIFFS_VIS_COUNTINUE;
        -: 1837:}
        -: 1838:
function spiffs_obj_lu_find_free_obj_id_compact_v called 0 returned 0% blocks executed 0%
    #####: 1839:static s32_t spiffs_obj_lu_find_free_obj_id_compact_v(spiffs *fs, spiffs_obj_id id, spiffs_block_ix bix, int ix_entry,
        -: 1840:    const void *user_const_p, void *user_var_p) {
        -: 1841:  (void)user_var_p;
    #####: 1842:  if (id != SPIFFS_OBJ_ID_FREE && id != SPIFFS_OBJ_ID_DELETED && (id & SPIFFS_OBJ_ID_IX_FLAG)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1843:    s32_t res;
    #####: 1844:    const spiffs_free_obj_id_state *state = (const spiffs_free_obj_id_state*)user_const_p;
        -: 1845:    spiffs_page_object_ix_header objix_hdr;
        -: 1846:
    #####: 1847:    res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -: 1848:        0, SPIFFS_OBJ_LOOKUP_ENTRY_TO_PADDR(fs, bix, ix_entry), sizeof(spiffs_page_object_ix_header), (u8_t*)&objix_hdr);
    #####: 1849:    if (res == SPIFFS_OK && objix_hdr.p_hdr.span_ix == 0 &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1850:        ((objix_hdr.p_hdr.flags & (SPIFFS_PH_FLAG_INDEX | SPIFFS_PH_FLAG_FINAL | SPIFFS_PH_FLAG_DELET)) ==
        -: 1851:            (SPIFFS_PH_FLAG_DELET))) {
        -: 1852:      // ok object look up entry
    #####: 1853:      if (state->conflicting_name && strcmp((const char *)state->conflicting_name, (char *)objix_hdr.name) == 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1854:        return SPIFFS_ERR_CONFLICTING_NAME;
        -: 1855:      }
        -: 1856:
    #####: 1857:      id &= ~SPIFFS_OBJ_ID_IX_FLAG;
    #####: 1858:      if (id >= state->min_obj_id && id <= state->max_obj_id) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1859:        u8_t *map = (u8_t *)fs->work;
    #####: 1860:        int ix = (id - state->min_obj_id) / state->compaction;
        -: 1861:        //SPIFFS_DBG("free_obj_id: add ix %i for id %04x min:%04x max%04x comp:%i\n", ix, id, state->min_obj_id, state->max_obj_id, state->compaction);
    #####: 1862:        map[ix]++;
        -: 1863:      }
        -: 1864:    }
        -: 1865:  }
    #####: 1866:  return SPIFFS_VIS_COUNTINUE;
        -: 1867:}
        -: 1868:
        -: 1869:// Scans thru all object lookup for object index header pages. If total possible number of
        -: 1870:// object ids cannot fit into a work buffer, these are grouped. When a group containing free
        -: 1871:// object ids is found, the object lu is again scanned for object ids within group and bitmasked.
        -: 1872:// Finally, the bitmask is searched for a free id
function spiffs_obj_lu_find_free_obj_id called 17 returned 100% blocks executed 45%
       17: 1873:s32_t spiffs_obj_lu_find_free_obj_id(spiffs *fs, spiffs_obj_id *obj_id, const u8_t *conflicting_name) {
       17: 1874:  s32_t res = SPIFFS_OK;
       17: 1875:  u32_t max_objects = (fs->block_count * SPIFFS_OBJ_LOOKUP_MAX_ENTRIES(fs)) / 2;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1876:  spiffs_free_obj_id_state state;
       17: 1877:  spiffs_obj_id free_obj_id = SPIFFS_OBJ_ID_FREE;
       17: 1878:  state.min_obj_id = 1;
       17: 1879:  state.max_obj_id = max_objects + 1;
       17: 1880:  if (state.max_obj_id & SPIFFS_OBJ_ID_IX_FLAG) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1881:    state.max_obj_id = ((spiffs_obj_id)-1) & ~SPIFFS_OBJ_ID_IX_FLAG;
        -: 1882:  }
       17: 1883:  state.compaction = 0;
       17: 1884:  state.conflicting_name = conflicting_name;
       34: 1885:  while (res == SPIFFS_OK && free_obj_id == SPIFFS_OBJ_ID_FREE) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       17: 1886:    if (state.max_obj_id - state.min_obj_id <= (spiffs_obj_id)SPIFFS_CFG_LOG_PAGE_SZ(fs)*8) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1887:      // possible to represent in bitmap
        -: 1888:      u32_t i, j;
        -: 1889:      SPIFFS_DBG("free_obj_id: BITM min:%04x max:%04x\n", state.min_obj_id, state.max_obj_id);
        -: 1890:
       17: 1891:      memset(fs->work, 0, SPIFFS_CFG_LOG_PAGE_SZ(fs));
       17: 1892:      res = spiffs_obj_lu_find_entry_visitor(fs, 0, 0, 0, 0, spiffs_obj_lu_find_free_obj_id_bitmap_v,
call    0 returned 100%
        -: 1893:          conflicting_name, &state.min_obj_id, 0, 0);
       17: 1894:      if (res == SPIFFS_VIS_END) res = SPIFFS_OK;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       17: 1895:      SPIFFS_CHECK_RES(res);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1896:      // traverse bitmask until found free obj_id
       17: 1897:      for (i = 0; i < SPIFFS_CFG_LOG_PAGE_SZ(fs); i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       17: 1898:        u8_t mask = fs->work[i];
       17: 1899:        if (mask == 0xff) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1900:          continue;
        -: 1901:        }
       35: 1902:        for (j = 0; j < 8; j++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       35: 1903:          if ((mask & (1<<j)) == 0) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
       17: 1904:            *obj_id = (i<<3)+j+state.min_obj_id;
       17: 1905:            return SPIFFS_OK;
        -: 1906:          }
        -: 1907:        }
        -: 1908:      }
    #####: 1909:      return SPIFFS_ERR_FULL;
        -: 1910:    } else {
        -: 1911:      // not possible to represent all ids in range in a bitmap, compact and count
    #####: 1912:      if (state.compaction != 0) {
branch  0 never executed
branch  1 never executed
        -: 1913:        // select element in compacted table, decrease range and recompact
    #####: 1914:        u32_t i, min_i = 0;
    #####: 1915:        u8_t *map = (u8_t *)fs->work;
    #####: 1916:        u8_t min_count = 0xff;
        -: 1917:
    #####: 1918:        for (i = 0; i < SPIFFS_CFG_LOG_PAGE_SZ(fs)/sizeof(u8_t); i++) {
branch  0 never executed
branch  1 never executed
    #####: 1919:          if (map[i] < min_count) {
branch  0 never executed
branch  1 never executed
    #####: 1920:            min_count = map[i];
    #####: 1921:            min_i = i;
    #####: 1922:            if (min_count == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1923:              break;
        -: 1924:            }
        -: 1925:          }
        -: 1926:        }
        -: 1927:
    #####: 1928:        if (min_count == state.compaction) {
branch  0 never executed
branch  1 never executed
        -: 1929:          // there are no free objids!
        -: 1930:          SPIFFS_DBG("free_obj_id: compacted table is full\n");
    #####: 1931:          return SPIFFS_ERR_FULL;
        -: 1932:        }
        -: 1933:
        -: 1934:        SPIFFS_DBG("free_obj_id: COMP select index:%i min_count:%i min:%04x max:%04x compact:%i\n", min_i, min_count, state.min_obj_id, state.max_obj_id, state.compaction);
        -: 1935:
    #####: 1936:        if (min_count == 0) {
branch  0 never executed
branch  1 never executed
        -: 1937:          // no id in this range, skip compacting and use directly
    #####: 1938:          *obj_id = min_i * state.compaction + state.min_obj_id;
    #####: 1939:          return SPIFFS_OK;
        -: 1940:        } else {
        -: 1941:          SPIFFS_DBG("free_obj_id: COMP SEL chunk:%04x min:%04x -> %04x\n", state.compaction, state.min_obj_id, state.min_obj_id + min_i *  state.compaction);
    #####: 1942:          state.min_obj_id += min_i *  state.compaction;
    #####: 1943:          state.max_obj_id = state.min_obj_id + state.compaction;
        -: 1944:          // decrease compaction
        -: 1945:        }
    #####: 1946:        if ((state.max_obj_id - state.min_obj_id <= (spiffs_obj_id)SPIFFS_CFG_LOG_PAGE_SZ(fs)*8)) {
branch  0 never executed
branch  1 never executed
        -: 1947:          // no need for compacting, use bitmap
    #####: 1948:          continue;
        -: 1949:        }
        -: 1950:      }
        -: 1951:      // in a work memory of log_page_size bytes, we may fit in log_page_size ids
        -: 1952:      // todo what if compaction is > 255 - then we cannot fit it in a byte
    #####: 1953:      state.compaction = (state.max_obj_id-state.min_obj_id) / ((SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(u8_t)));
        -: 1954:      SPIFFS_DBG("free_obj_id: COMP min:%04x max:%04x compact:%i\n", state.min_obj_id, state.max_obj_id, state.compaction);
        -: 1955:
    #####: 1956:      memset(fs->work, 0, SPIFFS_CFG_LOG_PAGE_SZ(fs));
    #####: 1957:      res = spiffs_obj_lu_find_entry_visitor(fs, 0, 0, 0, 0, spiffs_obj_lu_find_free_obj_id_compact_v, &state, 0, 0, 0);
call    0 never executed
    #####: 1958:      if (res == SPIFFS_VIS_END) res = SPIFFS_OK;
branch  0 never executed
branch  1 never executed
    #####: 1959:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####: 1960:      state.conflicting_name = 0; // searched for conflicting name once, no need to do it again
        -: 1961:    }
        -: 1962:  }
        -: 1963:
    #####: 1964:  return res;
        -: 1965:}
        -: 1966:#endif // !SPIFFS_READ_ONLY
        -: 1967:
function spiffs_fd_find_new called 23 returned 100% blocks executed 71%
       23: 1968:s32_t spiffs_fd_find_new(spiffs *fs, spiffs_fd **fd) {
        -: 1969:  u32_t i;
       23: 1970:  spiffs_fd *fds = (spiffs_fd *)fs->fd_space;
       23: 1971:  for (i = 0; i < fs->fd_count; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       23: 1972:    spiffs_fd *cur_fd = &fds[i];
       23: 1973:    if (cur_fd->file_nbr == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       23: 1974:      cur_fd->file_nbr = i+1;
       23: 1975:      *fd = cur_fd;
       23: 1976:      return SPIFFS_OK;
        -: 1977:    }
        -: 1978:  }
    #####: 1979:  return SPIFFS_ERR_OUT_OF_FILE_DESCS;
        -: 1980:}
        -: 1981:
function spiffs_fd_return called 23 returned 100% blocks executed 71%
       23: 1982:s32_t spiffs_fd_return(spiffs *fs, spiffs_file f) {
       23: 1983:  if (f <= 0 || f > (s16_t)fs->fd_count) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1984:    return SPIFFS_ERR_BAD_DESCRIPTOR;
        -: 1985:  }
       23: 1986:  spiffs_fd *fds = (spiffs_fd *)fs->fd_space;
       23: 1987:  spiffs_fd *fd = &fds[f-1];
       23: 1988:  if (fd->file_nbr == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1989:    return SPIFFS_ERR_FILE_CLOSED;
        -: 1990:  }
       23: 1991:  fd->file_nbr = 0;
       23: 1992:  return SPIFFS_OK;
        -: 1993:}
        -: 1994:
function spiffs_fd_get called 46781481 returned 100% blocks executed 71%
 46781481: 1995:s32_t spiffs_fd_get(spiffs *fs, spiffs_file f, spiffs_fd **fd) {
 46781481: 1996:  if (f <= 0 || f > (s16_t)fs->fd_count) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1997:    return SPIFFS_ERR_BAD_DESCRIPTOR;
        -: 1998:  }
 46781481: 1999:  spiffs_fd *fds = (spiffs_fd *)fs->fd_space;
 46781481: 2000:  *fd = &fds[f-1];
 46781481: 2001:  if ((*fd)->file_nbr == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2002:    return SPIFFS_ERR_FILE_CLOSED;
        -: 2003:  }
 46781481: 2004:  return SPIFFS_OK;
        -: 2005:}
