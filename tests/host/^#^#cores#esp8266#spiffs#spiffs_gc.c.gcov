        -:    0:Source:../../cores/esp8266/spiffs/spiffs_gc.c
        -:    0:Programs:16
        -:    1:#include "spiffs.h"
        -:    2:#include "spiffs_nucleus.h"
        -:    3:
        -:    4:#if !SPIFFS_READ_ONLY
        -:    5:
        -:    6:// Erases a logical block and updates the erase counter.
        -:    7:// If cache is enabled, all pages that might be cached in this block
        -:    8:// is dropped.
function spiffs_gc_erase_block called 0 returned 0% blocks executed 0%
    #####:    9:static s32_t spiffs_gc_erase_block(
        -:   10:    spiffs *fs,
        -:   11:    spiffs_block_ix bix) {
        -:   12:  s32_t res;
        -:   13:
        -:   14:  SPIFFS_GC_DBG("gc: erase block %i\n", bix);
    #####:   15:  res = spiffs_erase_block(fs, bix);
call    0 never executed
    #####:   16:  SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:   17:
        -:   18:#if SPIFFS_CACHE
        -:   19:  {
        -:   20:    u32_t i;
    #####:   21:    for (i = 0; i < SPIFFS_PAGES_PER_BLOCK(fs); i++) {
branch  0 never executed
branch  1 never executed
    #####:   22:      spiffs_cache_drop_page(fs, SPIFFS_PAGE_FOR_BLOCK(fs, bix) + i);
call    0 never executed
        -:   23:    }
        -:   24:  }
        -:   25:#endif
    #####:   26:  return res;
        -:   27:}
        -:   28:
        -:   29:// Searches for blocks where all entries are deleted - if one is found,
        -:   30:// the block is erased. Compared to the non-quick gc, the quick one ensures
        -:   31:// that no updates are needed on existing objects on pages that are erased.
function spiffs_gc_quick called 0 returned 0% blocks executed 0%
    #####:   32:s32_t spiffs_gc_quick(
        -:   33:    spiffs *fs, u16_t max_free_pages) {
    #####:   34:  s32_t res = SPIFFS_OK;
    #####:   35:  u32_t blocks = fs->block_count;
    #####:   36:  spiffs_block_ix cur_block = 0;
    #####:   37:  u32_t cur_block_addr = 0;
    #####:   38:  int cur_entry = 0;
    #####:   39:  spiffs_obj_id *obj_lu_buf = (spiffs_obj_id *)fs->lu_work;
        -:   40:
        -:   41:  SPIFFS_GC_DBG("gc_quick: running\n");
        -:   42:#if SPIFFS_GC_STATS
        -:   43:  fs->stats_gc_runs++;
        -:   44:#endif
        -:   45:
    #####:   46:  int entries_per_page = (SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(spiffs_obj_id));
        -:   47:
        -:   48:  // find fully deleted blocks
        -:   49:  // check each block
    #####:   50:  while (res == SPIFFS_OK && blocks--) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   51:    u16_t deleted_pages_in_block = 0;
    #####:   52:    u16_t free_pages_in_block = 0;
        -:   53:
    #####:   54:    int obj_lookup_page = 0;
        -:   55:    // check each object lookup page
    #####:   56:    while (res == SPIFFS_OK && obj_lookup_page < (int)SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   57:      int entry_offset = obj_lookup_page * entries_per_page;
    #####:   58:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:   59:          0, cur_block_addr + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
        -:   60:      // check each entry
    #####:   61:      while (res == SPIFFS_OK &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   62:          cur_entry - entry_offset < entries_per_page &&
branch  0 never executed
branch  1 never executed
    #####:   63:          cur_entry < (int)(SPIFFS_PAGES_PER_BLOCK(fs)-SPIFFS_OBJ_LOOKUP_PAGES(fs))) {
branch  0 never executed
branch  1 never executed
    #####:   64:        spiffs_obj_id obj_id = obj_lu_buf[cur_entry-entry_offset];
    #####:   65:        if (obj_id == SPIFFS_OBJ_ID_DELETED) {
branch  0 never executed
branch  1 never executed
    #####:   66:          deleted_pages_in_block++;
    #####:   67:        } else if (obj_id == SPIFFS_OBJ_ID_FREE) {
branch  0 never executed
branch  1 never executed
        -:   68:          // kill scan, go for next block
    #####:   69:          free_pages_in_block++;
    #####:   70:          if (free_pages_in_block > max_free_pages) {
branch  0 never executed
branch  1 never executed
    #####:   71:            obj_lookup_page = SPIFFS_OBJ_LOOKUP_PAGES(fs);
branch  0 never executed
branch  1 never executed
    #####:   72:            res = 1; // kill object lu loop
    #####:   73:            break;
        -:   74:          }
        -:   75:        }  else {
        -:   76:          // kill scan, go for next block
    #####:   77:          obj_lookup_page = SPIFFS_OBJ_LOOKUP_PAGES(fs);
branch  0 never executed
branch  1 never executed
    #####:   78:          res = 1; // kill object lu loop
    #####:   79:          break;
        -:   80:        }
    #####:   81:        cur_entry++;
        -:   82:      } // per entry
    #####:   83:      obj_lookup_page++;
        -:   84:    } // per object lookup page
    #####:   85:    if (res == 1) res = SPIFFS_OK;
branch  0 never executed
branch  1 never executed
        -:   86:
    #####:   87:    if (res == SPIFFS_OK &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   88:        deleted_pages_in_block + free_pages_in_block == SPIFFS_PAGES_PER_BLOCK(fs)-SPIFFS_OBJ_LOOKUP_PAGES(fs) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   89:        free_pages_in_block <= max_free_pages) {
        -:   90:      // found a fully deleted block
    #####:   91:      fs->stats_p_deleted -= deleted_pages_in_block;
    #####:   92:      res = spiffs_gc_erase_block(fs, cur_block);
call    0 never executed
    #####:   93:      return res;
        -:   94:    }
        -:   95:
    #####:   96:    cur_entry = 0;
    #####:   97:    cur_block++;
    #####:   98:    cur_block_addr += SPIFFS_CFG_LOG_BLOCK_SZ(fs);
        -:   99:  } // per block
        -:  100:
    #####:  101:  if (res == SPIFFS_OK) {
branch  0 never executed
branch  1 never executed
    #####:  102:    res = SPIFFS_ERR_NO_DELETED_BLOCKS;
        -:  103:  }
    #####:  104:  return res;
        -:  105:}
        -:  106:
        -:  107:// Checks if garbage collecting is necessary. If so a candidate block is found,
        -:  108:// cleansed and erased
function spiffs_gc_check called 31 returned 100% blocks executed 14%
       31:  109:s32_t spiffs_gc_check(
        -:  110:    spiffs *fs,
        -:  111:    u32_t len) {
        -:  112:  s32_t res;
      124:  113:  s32_t free_pages =
       62:  114:      (SPIFFS_PAGES_PER_BLOCK(fs) - SPIFFS_OBJ_LOOKUP_PAGES(fs)) * (fs->block_count-2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       62:  115:      - fs->stats_p_allocated - fs->stats_p_deleted;
       31:  116:  int tries = 0;
        -:  117:
       62:  118:  if (fs->free_blocks > 3 &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       31:  119:      (s32_t)len < free_pages * (s32_t)SPIFFS_DATA_PAGE_SIZE(fs)) {
       31:  120:    return SPIFFS_OK;
        -:  121:  }
        -:  122:
    #####:  123:  u32_t needed_pages = (len + SPIFFS_DATA_PAGE_SIZE(fs) - 1) / SPIFFS_DATA_PAGE_SIZE(fs);
        -:  124://  if (fs->free_blocks <= 2 && (s32_t)needed_pages > free_pages) {
        -:  125://    SPIFFS_GC_DBG("gc: full freeblk:%i needed:%i free:%i dele:%i\n", fs->free_blocks, needed_pages, free_pages, fs->stats_p_deleted);
        -:  126://    return SPIFFS_ERR_FULL;
        -:  127://  }
    #####:  128:  if ((s32_t)needed_pages > (s32_t)(free_pages + fs->stats_p_deleted)) {
branch  0 never executed
branch  1 never executed
        -:  129:    SPIFFS_GC_DBG("gc_check: full freeblk:%i needed:%i free:%i dele:%i\n", fs->free_blocks, needed_pages, free_pages, fs->stats_p_deleted);
    #####:  130:    return SPIFFS_ERR_FULL;
        -:  131:  }
        -:  132:
        -:  133:  do {
        -:  134:    SPIFFS_GC_DBG("\ngc_check #%i: run gc free_blocks:%i pfree:%i pallo:%i pdele:%i [%i] len:%i of %i\n",
        -:  135:        tries,
        -:  136:        fs->free_blocks, free_pages, fs->stats_p_allocated, fs->stats_p_deleted, (free_pages+fs->stats_p_allocated+fs->stats_p_deleted),
        -:  137:        len, free_pages*SPIFFS_DATA_PAGE_SIZE(fs));
        -:  138:
        -:  139:    spiffs_block_ix *cands;
        -:  140:    int count;
        -:  141:    spiffs_block_ix cand;
    #####:  142:    s32_t prev_free_pages = free_pages;
        -:  143:    // if the fs is crammed, ignore block age when selecting candidate - kind of a bad state
    #####:  144:    res = spiffs_gc_find_candidate(fs, &cands, &count, free_pages <= 0);
call    0 never executed
    #####:  145:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  146:    if (count == 0) {
branch  0 never executed
branch  1 never executed
        -:  147:      SPIFFS_GC_DBG("gc_check: no candidates, return\n");
    #####:  148:      return (s32_t)needed_pages < free_pages ? SPIFFS_OK : SPIFFS_ERR_FULL;
branch  0 never executed
branch  1 never executed
        -:  149:    }
        -:  150:#if SPIFFS_GC_STATS
        -:  151:    fs->stats_gc_runs++;
        -:  152:#endif
    #####:  153:    cand = cands[0];
    #####:  154:    fs->cleaning = 1;
        -:  155:    //printf("gcing: cleaning block %i\n", cand);
    #####:  156:    res = spiffs_gc_clean(fs, cand);
call    0 never executed
    #####:  157:    fs->cleaning = 0;
        -:  158:    if (res < 0) {
        -:  159:      SPIFFS_GC_DBG("gc_check: cleaning block %i, result %i\n", cand, res);
        -:  160:    } else {
        -:  161:      SPIFFS_GC_DBG("gc_check: cleaning block %i, result %i\n", cand, res);
        -:  162:    }
    #####:  163:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  164:
    #####:  165:    res = spiffs_gc_erase_page_stats(fs, cand);
call    0 never executed
    #####:  166:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  167:
    #####:  168:    res = spiffs_gc_erase_block(fs, cand);
call    0 never executed
    #####:  169:    SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  170:
    #####:  171:    free_pages =
    #####:  172:          (SPIFFS_PAGES_PER_BLOCK(fs) - SPIFFS_OBJ_LOOKUP_PAGES(fs)) * (fs->block_count - 2)
branch  0 never executed
branch  1 never executed
    #####:  173:          - fs->stats_p_allocated - fs->stats_p_deleted;
        -:  174:
    #####:  175:    if (prev_free_pages <= 0 && prev_free_pages == free_pages) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  176:      // abort early to reduce wear, at least tried once
        -:  177:      SPIFFS_GC_DBG("gc_check: early abort, no result on gc when fs crammed\n");
    #####:  178:      break;
        -:  179:    }
        -:  180:
    #####:  181:  } while (++tries < SPIFFS_GC_MAX_RUNS && (fs->free_blocks <= 2 ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  182:      (s32_t)len > free_pages*(s32_t)SPIFFS_DATA_PAGE_SIZE(fs)));
branch  0 never executed
branch  1 never executed
        -:  183:
    #####:  184:  free_pages =
    #####:  185:        (SPIFFS_PAGES_PER_BLOCK(fs) - SPIFFS_OBJ_LOOKUP_PAGES(fs)) * (fs->block_count - 2)
branch  0 never executed
branch  1 never executed
    #####:  186:        - fs->stats_p_allocated - fs->stats_p_deleted;
    #####:  187:  if ((s32_t)len > free_pages*(s32_t)SPIFFS_DATA_PAGE_SIZE(fs)) {
branch  0 never executed
branch  1 never executed
    #####:  188:    res = SPIFFS_ERR_FULL;
        -:  189:  }
        -:  190:
        -:  191:  SPIFFS_GC_DBG("gc_check: finished, %i dirty, blocks %i free, %i pages free, %i tries, res %i\n",
        -:  192:      fs->stats_p_allocated + fs->stats_p_deleted,
        -:  193:      fs->free_blocks, free_pages, tries, res);
        -:  194:
    #####:  195:  return res;
        -:  196:}
        -:  197:
        -:  198:// Updates page statistics for a block that is about to be erased
function spiffs_gc_erase_page_stats called 0 returned 0% blocks executed 0%
    #####:  199:s32_t spiffs_gc_erase_page_stats(
        -:  200:    spiffs *fs,
        -:  201:    spiffs_block_ix bix) {
    #####:  202:  s32_t res = SPIFFS_OK;
    #####:  203:  int obj_lookup_page = 0;
    #####:  204:  int entries_per_page = (SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(spiffs_obj_id));
    #####:  205:  spiffs_obj_id *obj_lu_buf = (spiffs_obj_id *)fs->lu_work;
    #####:  206:  int cur_entry = 0;
    #####:  207:  u32_t dele = 0;
    #####:  208:  u32_t allo = 0;
        -:  209:
        -:  210:  // check each object lookup page
    #####:  211:  while (res == SPIFFS_OK && obj_lookup_page < (int)SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  212:    int entry_offset = obj_lookup_page * entries_per_page;
    #####:  213:    res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  214:        0, bix * SPIFFS_CFG_LOG_BLOCK_SZ(fs) + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
        -:  215:    // check each entry
    #####:  216:    while (res == SPIFFS_OK &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  217:        cur_entry - entry_offset < entries_per_page && cur_entry < (int)(SPIFFS_PAGES_PER_BLOCK(fs)-SPIFFS_OBJ_LOOKUP_PAGES(fs))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  218:      spiffs_obj_id obj_id = obj_lu_buf[cur_entry-entry_offset];
    #####:  219:      if (obj_id == SPIFFS_OBJ_ID_FREE) {
branch  0 never executed
branch  1 never executed
    #####:  220:      } else if (obj_id == SPIFFS_OBJ_ID_DELETED) {
branch  0 never executed
branch  1 never executed
    #####:  221:        dele++;
        -:  222:      } else {
    #####:  223:        allo++;
        -:  224:      }
    #####:  225:      cur_entry++;
        -:  226:    } // per entry
    #####:  227:    obj_lookup_page++;
        -:  228:  } // per object lookup page
        -:  229:  SPIFFS_GC_DBG("gc_check: wipe pallo:%i pdele:%i\n", allo, dele);
    #####:  230:  fs->stats_p_allocated -= allo;
    #####:  231:  fs->stats_p_deleted -= dele;
    #####:  232:  return res;
        -:  233:}
        -:  234:
        -:  235:// Finds block candidates to erase
function spiffs_gc_find_candidate called 0 returned 0% blocks executed 0%
    #####:  236:s32_t spiffs_gc_find_candidate(
        -:  237:    spiffs *fs,
        -:  238:    spiffs_block_ix **block_candidates,
        -:  239:    int *candidate_count,
        -:  240:    char fs_crammed) {
    #####:  241:  s32_t res = SPIFFS_OK;
    #####:  242:  u32_t blocks = fs->block_count;
    #####:  243:  spiffs_block_ix cur_block = 0;
    #####:  244:  u32_t cur_block_addr = 0;
    #####:  245:  spiffs_obj_id *obj_lu_buf = (spiffs_obj_id *)fs->lu_work;
    #####:  246:  int cur_entry = 0;
        -:  247:
        -:  248:  // using fs->work area as sorted candidate memory, (spiffs_block_ix)cand_bix/(s32_t)score
    #####:  249:  int max_candidates = MIN(fs->block_count, (SPIFFS_CFG_LOG_PAGE_SZ(fs)-8)/(sizeof(spiffs_block_ix) + sizeof(s32_t)));
    #####:  250:  *candidate_count = 0;
    #####:  251:  memset(fs->work, 0xff, SPIFFS_CFG_LOG_PAGE_SZ(fs));
        -:  252:
        -:  253:  // divide up work area into block indices and scores
    #####:  254:  spiffs_block_ix *cand_blocks = (spiffs_block_ix *)fs->work;
    #####:  255:  s32_t *cand_scores = (s32_t *)(fs->work + max_candidates * sizeof(spiffs_block_ix));
        -:  256:
        -:  257:   // align cand_scores on s32_t boundary
        -:  258:#pragma GCC diagnostic push
        -:  259:#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
    #####:  260:  cand_scores = (s32_t*)(((ptrdiff_t)cand_scores + sizeof(ptrdiff_t) - 1) & ~(sizeof(ptrdiff_t) - 1));
        -:  261:#pragma GCC diagnostic pop
        -:  262:
    #####:  263:  *block_candidates = cand_blocks;
        -:  264:
    #####:  265:  int entries_per_page = (SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(spiffs_obj_id));
        -:  266:
        -:  267:  // check each block
    #####:  268:  while (res == SPIFFS_OK && blocks--) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  269:    u16_t deleted_pages_in_block = 0;
    #####:  270:    u16_t used_pages_in_block = 0;
        -:  271:
    #####:  272:    int obj_lookup_page = 0;
        -:  273:    // check each object lookup page
    #####:  274:    while (res == SPIFFS_OK && obj_lookup_page < (int)SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  275:      int entry_offset = obj_lookup_page * entries_per_page;
    #####:  276:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  277:          0, cur_block_addr + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
        -:  278:      // check each entry
    #####:  279:      while (res == SPIFFS_OK &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  280:          cur_entry - entry_offset < entries_per_page &&
branch  0 never executed
branch  1 never executed
    #####:  281:          cur_entry < (int)(SPIFFS_PAGES_PER_BLOCK(fs)-SPIFFS_OBJ_LOOKUP_PAGES(fs))) {
branch  0 never executed
branch  1 never executed
    #####:  282:        spiffs_obj_id obj_id = obj_lu_buf[cur_entry-entry_offset];
    #####:  283:        if (obj_id == SPIFFS_OBJ_ID_FREE) {
branch  0 never executed
branch  1 never executed
        -:  284:          // when a free entry is encountered, scan logic ensures that all following entries are free also
    #####:  285:          res = 1; // kill object lu loop
    #####:  286:          break;
    #####:  287:        } else  if (obj_id == SPIFFS_OBJ_ID_DELETED) {
branch  0 never executed
branch  1 never executed
    #####:  288:          deleted_pages_in_block++;
        -:  289:        } else {
    #####:  290:          used_pages_in_block++;
        -:  291:        }
    #####:  292:        cur_entry++;
        -:  293:      } // per entry
    #####:  294:      obj_lookup_page++;
        -:  295:    } // per object lookup page
    #####:  296:    if (res == 1) res = SPIFFS_OK;
branch  0 never executed
branch  1 never executed
        -:  297:
        -:  298:    // calculate score and insert into candidate table
        -:  299:    // stoneage sort, but probably not so many blocks
    #####:  300:    if (res == SPIFFS_OK && deleted_pages_in_block > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  301:      // read erase count
        -:  302:      spiffs_obj_id erase_count;
    #####:  303:      res = _spiffs_rd(fs, SPIFFS_OP_C_READ | SPIFFS_OP_T_OBJ_LU2, 0,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  304:          SPIFFS_ERASE_COUNT_PADDR(fs, cur_block),
        -:  305:          sizeof(spiffs_obj_id), (u8_t *)&erase_count);
    #####:  306:      SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  307:
        -:  308:      spiffs_obj_id erase_age;
    #####:  309:      if (fs->max_erase_count > erase_count) {
branch  0 never executed
branch  1 never executed
    #####:  310:        erase_age = fs->max_erase_count - erase_count;
        -:  311:      } else {
    #####:  312:        erase_age = SPIFFS_OBJ_ID_FREE - (erase_count - fs->max_erase_count);
        -:  313:      }
        -:  314:
    #####:  315:      s32_t score =
    #####:  316:          deleted_pages_in_block * SPIFFS_GC_HEUR_W_DELET +
        -:  317:          used_pages_in_block * SPIFFS_GC_HEUR_W_USED +
    #####:  318:          erase_age * (fs_crammed ? 0 : SPIFFS_GC_HEUR_W_ERASE_AGE);
branch  0 never executed
branch  1 never executed
    #####:  319:      int cand_ix = 0;
        -:  320:      SPIFFS_GC_DBG("gc_check: bix:%i del:%i use:%i score:%i\n", cur_block, deleted_pages_in_block, used_pages_in_block, score);
    #####:  321:      while (cand_ix < max_candidates) {
branch  0 never executed
branch  1 never executed
    #####:  322:        if (cand_blocks[cand_ix] == (spiffs_block_ix)-1) {
branch  0 never executed
branch  1 never executed
    #####:  323:          cand_blocks[cand_ix] = cur_block;
    #####:  324:          cand_scores[cand_ix] = score;
    #####:  325:          break;
    #####:  326:        } else if (cand_scores[cand_ix] < score) {
branch  0 never executed
branch  1 never executed
    #####:  327:          int reorder_cand_ix = max_candidates - 2;
    #####:  328:          while (reorder_cand_ix >= cand_ix) {
branch  0 never executed
branch  1 never executed
    #####:  329:            cand_blocks[reorder_cand_ix + 1] = cand_blocks[reorder_cand_ix];
    #####:  330:            cand_scores[reorder_cand_ix + 1] = cand_scores[reorder_cand_ix];
    #####:  331:            reorder_cand_ix--;
        -:  332:          }
    #####:  333:          cand_blocks[cand_ix] = cur_block;
    #####:  334:          cand_scores[cand_ix] = score;
    #####:  335:          break;
        -:  336:        }
    #####:  337:        cand_ix++;
        -:  338:      }
    #####:  339:      (*candidate_count)++;
        -:  340:    }
        -:  341:
    #####:  342:    cur_entry = 0;
    #####:  343:    cur_block++;
    #####:  344:    cur_block_addr += SPIFFS_CFG_LOG_BLOCK_SZ(fs);
        -:  345:  } // per block
        -:  346:
    #####:  347:  return res;
        -:  348:}
        -:  349:
        -:  350:typedef enum {
        -:  351:  FIND_OBJ_DATA,
        -:  352:  MOVE_OBJ_DATA,
        -:  353:  MOVE_OBJ_IX,
        -:  354:  FINISHED
        -:  355:} spiffs_gc_clean_state;
        -:  356:
        -:  357:typedef struct {
        -:  358:  spiffs_gc_clean_state state;
        -:  359:  spiffs_obj_id cur_obj_id;
        -:  360:  spiffs_span_ix cur_objix_spix;
        -:  361:  spiffs_page_ix cur_objix_pix;
        -:  362:  int stored_scan_entry_index;
        -:  363:  u8_t obj_id_found;
        -:  364:} spiffs_gc;
        -:  365:
        -:  366:// Empties given block by moving all data into free pages of another block
        -:  367:// Strategy:
        -:  368://   loop:
        -:  369://   scan object lookup for object data pages
        -:  370://   for first found id, check spix and load corresponding object index page to memory
        -:  371://   push object scan lookup entry index
        -:  372://     rescan object lookup, find data pages with same id and referenced by same object index
        -:  373://     move data page, update object index in memory
        -:  374://     when reached end of lookup, store updated object index
        -:  375://   pop object scan lookup entry index
        -:  376://   repeat loop until end of object lookup
        -:  377://   scan object lookup again for remaining object index pages, move to new page in other block
        -:  378://
function spiffs_gc_clean called 0 returned 0% blocks executed 0%
    #####:  379:s32_t spiffs_gc_clean(spiffs *fs, spiffs_block_ix bix) {
    #####:  380:  s32_t res = SPIFFS_OK;
    #####:  381:  int entries_per_page = (SPIFFS_CFG_LOG_PAGE_SZ(fs) / sizeof(spiffs_obj_id));
    #####:  382:  int cur_entry = 0;
    #####:  383:  spiffs_obj_id *obj_lu_buf = (spiffs_obj_id *)fs->lu_work;
        -:  384:  spiffs_gc gc;
    #####:  385:  spiffs_page_ix cur_pix = 0;
    #####:  386:  spiffs_page_object_ix_header *objix_hdr = (spiffs_page_object_ix_header *)fs->work;
    #####:  387:  spiffs_page_object_ix *objix = (spiffs_page_object_ix *)fs->work;
        -:  388:
        -:  389:  SPIFFS_GC_DBG("gc_clean: cleaning block %i\n", bix);
        -:  390:
    #####:  391:  memset(&gc, 0, sizeof(spiffs_gc));
    #####:  392:  gc.state = FIND_OBJ_DATA;
        -:  393:
    #####:  394:  if (fs->free_cursor_block_ix == bix) {
branch  0 never executed
branch  1 never executed
        -:  395:    // move free cursor to next block, cannot use free pages from the block we want to clean
    #####:  396:    fs->free_cursor_block_ix = (bix+1)%fs->block_count;
    #####:  397:    fs->free_cursor_obj_lu_entry = 0;
        -:  398:    SPIFFS_GC_DBG("gc_clean: move free cursor to block %i\n", fs->free_cursor_block_ix);
        -:  399:  }
        -:  400:
    #####:  401:  while (res == SPIFFS_OK && gc.state != FINISHED) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  402:    SPIFFS_GC_DBG("gc_clean: state = %i entry:%i\n", gc.state, cur_entry);
    #####:  403:    gc.obj_id_found = 0;
        -:  404:
        -:  405:    // scan through lookup pages
    #####:  406:    int obj_lookup_page = cur_entry / entries_per_page;
    #####:  407:    u8_t scan = 1;
        -:  408:    // check each object lookup page
    #####:  409:    while (scan && res == SPIFFS_OK && obj_lookup_page < (int)SPIFFS_OBJ_LOOKUP_PAGES(fs)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:  410:      int entry_offset = obj_lookup_page * entries_per_page;
    #####:  411:      res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  412:          0, bix * SPIFFS_CFG_LOG_BLOCK_SZ(fs) + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page),
        -:  413:          SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
        -:  414:      // check each entry
    #####:  415:      while (scan && res == SPIFFS_OK &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  416:          cur_entry - entry_offset < entries_per_page && cur_entry < (int)(SPIFFS_PAGES_PER_BLOCK(fs)-SPIFFS_OBJ_LOOKUP_PAGES(fs))) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  417:        spiffs_obj_id obj_id = obj_lu_buf[cur_entry-entry_offset];
    #####:  418:        cur_pix = SPIFFS_OBJ_LOOKUP_ENTRY_TO_PIX(fs, bix, cur_entry);
branch  0 never executed
branch  1 never executed
        -:  419:
        -:  420:        // act upon object id depending on gc state
    #####:  421:        switch (gc.state) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  422:        case FIND_OBJ_DATA:
    #####:  423:          if (obj_id != SPIFFS_OBJ_ID_DELETED && obj_id != SPIFFS_OBJ_ID_FREE &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  424:              ((obj_id & SPIFFS_OBJ_ID_IX_FLAG) == 0)) {
        -:  425:            SPIFFS_GC_DBG("gc_clean: FIND_DATA state:%i - found obj id %04x\n", gc.state, obj_id);
    #####:  426:            gc.obj_id_found = 1;
    #####:  427:            gc.cur_obj_id = obj_id;
    #####:  428:            scan = 0;
        -:  429:          }
    #####:  430:          break;
        -:  431:        case MOVE_OBJ_DATA:
    #####:  432:          if (obj_id == gc.cur_obj_id) {
branch  0 never executed
branch  1 never executed
        -:  433:            spiffs_page_header p_hdr;
    #####:  434:            res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -:  435:                0, SPIFFS_PAGE_TO_PADDR(fs, cur_pix), sizeof(spiffs_page_header), (u8_t*)&p_hdr);
    #####:  436:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  437:            SPIFFS_GC_DBG("gc_clean: MOVE_DATA found data page %04x:%04x @ %04x\n", gc.cur_obj_id, p_hdr.span_ix, cur_pix);
    #####:  438:            if (SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, p_hdr.span_ix) != gc.cur_objix_spix) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  439:              SPIFFS_GC_DBG("gc_clean: MOVE_DATA no objix spix match, take in another run\n");
        -:  440:            } else {
        -:  441:              spiffs_page_ix new_data_pix;
    #####:  442:              if (p_hdr.flags & SPIFFS_PH_FLAG_DELET) {
branch  0 never executed
branch  1 never executed
        -:  443:                // move page
    #####:  444:                res = spiffs_page_move(fs, 0, 0, obj_id, &p_hdr, cur_pix, &new_data_pix);
call    0 never executed
        -:  445:                SPIFFS_GC_DBG("gc_clean: MOVE_DATA move objix %04x:%04x page %04x to %04x\n", gc.cur_obj_id, p_hdr.span_ix, cur_pix, new_data_pix);
    #####:  446:                SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  447:                // move wipes obj_lu, reload it
    #####:  448:                res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  449:                    0, bix * SPIFFS_CFG_LOG_BLOCK_SZ(fs) + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page),
        -:  450:                    SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
    #####:  451:                SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  452:              } else {
        -:  453:                // page is deleted but not deleted in lookup, scrap it
        -:  454:                SPIFFS_GC_DBG("gc_clean: MOVE_DATA wipe objix %04x:%04x page %04x\n", obj_id, p_hdr.span_ix, cur_pix);
    #####:  455:                res = spiffs_page_delete(fs, cur_pix);
call    0 never executed
    #####:  456:                SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  457:                new_data_pix = SPIFFS_OBJ_ID_FREE;
        -:  458:              }
        -:  459:              // update memory representation of object index page with new data page
    #####:  460:              if (gc.cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -:  461:                // update object index header page
    #####:  462:                ((spiffs_page_ix*)((u8_t *)objix_hdr + sizeof(spiffs_page_object_ix_header)))[p_hdr.span_ix] = new_data_pix;
        -:  463:                SPIFFS_GC_DBG("gc_clean: MOVE_DATA wrote page %04x to objix_hdr entry %02x in mem\n", new_data_pix, SPIFFS_OBJ_IX_ENTRY(fs, p_hdr.span_ix));
        -:  464:              } else {
        -:  465:                // update object index page
    #####:  466:                ((spiffs_page_ix*)((u8_t *)objix + sizeof(spiffs_page_object_ix)))[SPIFFS_OBJ_IX_ENTRY(fs, p_hdr.span_ix)] = new_data_pix;
branch  0 never executed
branch  1 never executed
        -:  467:                SPIFFS_GC_DBG("gc_clean: MOVE_DATA wrote page %04x to objix entry %02x in mem\n", new_data_pix, SPIFFS_OBJ_IX_ENTRY(fs, p_hdr.span_ix));
        -:  468:              }
        -:  469:            }
        -:  470:          }
    #####:  471:          break;
        -:  472:        case MOVE_OBJ_IX:
    #####:  473:          if (obj_id != SPIFFS_OBJ_ID_DELETED && obj_id != SPIFFS_OBJ_ID_FREE &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  474:              (obj_id & SPIFFS_OBJ_ID_IX_FLAG)) {
        -:  475:            // found an index object id
        -:  476:            spiffs_page_header p_hdr;
        -:  477:            spiffs_page_ix new_pix;
        -:  478:            // load header
    #####:  479:            res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -:  480:                0, SPIFFS_PAGE_TO_PADDR(fs, cur_pix), sizeof(spiffs_page_header), (u8_t*)&p_hdr);
    #####:  481:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  482:            if (p_hdr.flags & SPIFFS_PH_FLAG_DELET) {
branch  0 never executed
branch  1 never executed
        -:  483:              // move page
    #####:  484:              res = spiffs_page_move(fs, 0, 0, obj_id, &p_hdr, cur_pix, &new_pix);
call    0 never executed
        -:  485:              SPIFFS_GC_DBG("gc_clean: MOVE_OBJIX move objix %04x:%04x page %04x to %04x\n", obj_id, p_hdr.span_ix, cur_pix, new_pix);
    #####:  486:              SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  487:              spiffs_cb_object_event(fs, 0, SPIFFS_EV_IX_UPD, obj_id, p_hdr.span_ix, new_pix, 0);
call    0 never executed
        -:  488:              // move wipes obj_lu, reload it
    #####:  489:              res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU | SPIFFS_OP_C_READ,
call    0 never executed
        -:  490:                  0, bix * SPIFFS_CFG_LOG_BLOCK_SZ(fs) + SPIFFS_PAGE_TO_PADDR(fs, obj_lookup_page),
        -:  491:                  SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->lu_work);
    #####:  492:              SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  493:            } else {
        -:  494:              // page is deleted but not deleted in lookup, scrap it
        -:  495:              SPIFFS_GC_DBG("gc_clean: MOVE_OBJIX wipe objix %04x:%04x page %04x\n", obj_id, p_hdr.span_ix, cur_pix);
    #####:  496:              res = spiffs_page_delete(fs, cur_pix);
call    0 never executed
    #####:  497:              if (res == SPIFFS_OK) {
branch  0 never executed
branch  1 never executed
    #####:  498:                spiffs_cb_object_event(fs, 0, SPIFFS_EV_IX_DEL, obj_id, p_hdr.span_ix, cur_pix, 0);
call    0 never executed
        -:  499:              }
        -:  500:            }
    #####:  501:            SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  502:          }
    #####:  503:          break;
        -:  504:        default:
    #####:  505:          scan = 0;
    #####:  506:          break;
        -:  507:        }
    #####:  508:        cur_entry++;
        -:  509:      } // per entry
    #####:  510:      obj_lookup_page++;
        -:  511:    } // per object lookup page
        -:  512:
    #####:  513:    if (res != SPIFFS_OK) break;
branch  0 never executed
branch  1 never executed
        -:  514:
        -:  515:    // state finalization and switch
    #####:  516:    switch (gc.state) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  517:    case FIND_OBJ_DATA:
    #####:  518:      if (gc.obj_id_found) {
branch  0 never executed
branch  1 never executed
        -:  519:        // find out corresponding obj ix page and load it to memory
        -:  520:        spiffs_page_header p_hdr;
        -:  521:        spiffs_page_ix objix_pix;
    #####:  522:        gc.stored_scan_entry_index = cur_entry;
    #####:  523:        cur_entry = 0;
    #####:  524:        gc.state = MOVE_OBJ_DATA;
    #####:  525:        res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -:  526:            0, SPIFFS_PAGE_TO_PADDR(fs, cur_pix), sizeof(spiffs_page_header), (u8_t*)&p_hdr);
    #####:  527:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  528:        gc.cur_objix_spix = SPIFFS_OBJ_IX_ENTRY_SPAN_IX(fs, p_hdr.span_ix);
branch  0 never executed
branch  1 never executed
        -:  529:        SPIFFS_GC_DBG("gc_clean: FIND_DATA find objix span_ix:%04x\n", gc.cur_objix_spix);
    #####:  530:        res = spiffs_obj_lu_find_id_and_span(fs, gc.cur_obj_id | SPIFFS_OBJ_ID_IX_FLAG, gc.cur_objix_spix, 0, &objix_pix);
call    0 never executed
    #####:  531:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  532:        SPIFFS_GC_DBG("gc_clean: FIND_DATA found object index at page %04x\n", objix_pix);
    #####:  533:        res = _spiffs_rd(fs, SPIFFS_OP_T_OBJ_LU2 | SPIFFS_OP_C_READ,
call    0 never executed
        -:  534:            0, SPIFFS_PAGE_TO_PADDR(fs, objix_pix), SPIFFS_CFG_LOG_PAGE_SZ(fs), fs->work);
    #####:  535:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  536:        SPIFFS_VALIDATE_OBJIX(objix->p_hdr, gc.cur_obj_id | SPIFFS_OBJ_ID_IX_FLAG, gc.cur_objix_spix);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:  537:        gc.cur_objix_pix = objix_pix;
        -:  538:      } else {
    #####:  539:        gc.state = MOVE_OBJ_IX;
    #####:  540:        cur_entry = 0; // restart entry scan index
        -:  541:      }
    #####:  542:      break;
        -:  543:    case MOVE_OBJ_DATA: {
        -:  544:      // store modified objix (hdr) page
        -:  545:      spiffs_page_ix new_objix_pix;
    #####:  546:      gc.state = FIND_OBJ_DATA;
    #####:  547:      cur_entry = gc.stored_scan_entry_index;
    #####:  548:      if (gc.cur_objix_spix == 0) {
branch  0 never executed
branch  1 never executed
        -:  549:        // store object index header page
    #####:  550:        res = spiffs_object_update_index_hdr(fs, 0, gc.cur_obj_id | SPIFFS_OBJ_ID_IX_FLAG, gc.cur_objix_pix, fs->work, 0, 0, &new_objix_pix);
call    0 never executed
        -:  551:        SPIFFS_GC_DBG("gc_clean: MOVE_DATA store modified objix_hdr page, %04x:%04x\n", new_objix_pix, 0);
    #####:  552:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
        -:  553:      } else {
        -:  554:        // store object index page
    #####:  555:        res = spiffs_page_move(fs, 0, fs->work, gc.cur_obj_id | SPIFFS_OBJ_ID_IX_FLAG, 0, gc.cur_objix_pix, &new_objix_pix);
call    0 never executed
        -:  556:        SPIFFS_GC_DBG("gc_clean: MOVE_DATA store modified objix page, %04x:%04x\n", new_objix_pix, objix->p_hdr.span_ix);
    #####:  557:        SPIFFS_CHECK_RES(res);
branch  0 never executed
branch  1 never executed
    #####:  558:        spiffs_cb_object_event(fs, 0, SPIFFS_EV_IX_UPD, gc.cur_obj_id, objix->p_hdr.span_ix, new_objix_pix, 0);
call    0 never executed
        -:  559:      }
        -:  560:    }
    #####:  561:    break;
        -:  562:    case MOVE_OBJ_IX:
    #####:  563:      gc.state = FINISHED;
    #####:  564:      break;
        -:  565:    default:
    #####:  566:      cur_entry = 0;
    #####:  567:      break;
        -:  568:    }
        -:  569:    SPIFFS_GC_DBG("gc_clean: state-> %i\n", gc.state);
        -:  570:  } // while state != FINISHED
        -:  571:
        -:  572:
    #####:  573:  return res;
        -:  574:}
        -:  575:
        -:  576:#endif // !SPIFFS_READ_ONLY
